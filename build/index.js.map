{
  "version": 3,
  "sources": ["../src/constants/Keys.ts", "../src/constants/ScreenConstants.ts", "../src/math/Common.ts", "../src/utils/Color.ts", "../src/Canvas.ts", "../src/math/Vector.ts", "../src/game-modes/GameEvent.ts", "../src/math/Shapes.ts", "../src/room/Player.ts", "../src/room/Room.ts", "../src/room/RoomWeb.ts", "../src/game-modes/MapMode.ts", "../src/game-modes/PlayMode.ts", "../src/GameModeManager.ts", "../src/InputManager.ts", "../src/ScreenManager.ts", "../src/App.ts"],
  "sourcesContent": ["const Up = Symbol(\"Up\");\nconst Down = Symbol(\"Down\");\nconst Left = Symbol(\"Left\");\nconst Right = Symbol(\"Right\");\nconst Jump = Symbol(\"Jump\");\nconst Interact = Symbol(\"Interact\");\nconst Escape = Symbol(\"Escape\");\nconst Map = Symbol(\"Map\");\n\n// TODO Convert this to an enum\nexport const Input = {\n  Down,\n  Escape,\n  Interact,\n  Jump,\n  Left,\n  Right,\n  Up,\n  Map,\n};\n", "export const CANVAS_WIDTH = 1280;\nexport const CANVAS_HEIGHT = 720;\n\n// export const HORIZONTAL_TILES = 32;\n// export const VERTICAL_TILES = 18;\n\n// export const PIXELS_PER_TILE = 10;\n\n// export const PIXEL_WIDTH = CANVAS_WIDTH / HORIZONTAL_TILES / PIXELS_PER_TILE;\n\nexport const IS_MOBILE =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent\n  );\n\nexport const ON_SCREEN_CANVAS_WIDTH = 1280;\nexport const ON_SCREEN_CANVAS_HEIGHT = 720;\n", "/**\n * Clamps a parameter between a low and high bound.\n * @param {number} x The number to be clamped\n * @param {number} low The lowest value that could be returned\n * @param {number} high The highest value that could be returned\n */\nexport const clamp = (x: number, low: number, high: number): number => {\n  return Math.min(high, Math.max(x, low));\n};\n\nexport const sign = (x: number): number => {\n  if (x > 0) {\n    return 1;\n  } else if (x === 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n};\n\nexport const floorTo = (x: number, fidelity: number): number => {\n  return fidelity * Math.floor(x / fidelity);\n};\n", "const HEX = 16;\nconst ZERO = \"0\";\n\n/**\n * A function to convert a number to a zero-padded hex string.\n * @param {number} number The number to be converted\n * @param {number} digits The expected length (for zero-padding purposes)\n */\nexport const toHex = (number: number, digits: number) => {\n  return number.toString(HEX).padStart(digits, ZERO);\n};\n\nexport const rgbaColor = (\n  red: number,\n  green: number,\n  blue: number,\n  alpha = 255\n) => {\n  return `#${toHex(red, 2)}${toHex(green, 2)}${toHex(blue, 2)}${toHex(\n    alpha,\n    2\n  )}`;\n};\n\nexport const hslaColor = (\n  hue: number,\n  saturation: number,\n  lightness: number,\n  alpha = 1\n) => {\n  return `hsla(${hue},${Math.floor(saturation * 100)}%,${Math.floor(\n    lightness * 100\n  )}%,${alpha})`;\n};\n\nconst rgbToHue = (r: number, g: number, b: number): number => {\n  let h = 0;\n\n  const min = Math.min(r, g, b);\n  const max = Math.max(r, g, b);\n\n  if (max === r) {\n    h = (g - b) / (max - min);\n  }\n  if (max === g) {\n    h = 2 + (b - r) / (max - min);\n  }\n  if (max === b) {\n    h = 4 + (r - g) / (max - min);\n  }\n  if (isNaN(h)) {\n    h = 0;\n  }\n  h = h * 60;\n  if (h < 0) {\n    h = h + 360;\n  }\n  return h;\n};\n\nconst fromHex = (hexColor: string): [number, number, number] => {\n  return [\n    parseInt(hexColor.slice(1, 3), 16),\n    parseInt(hexColor.slice(3, 5), 16),\n    parseInt(hexColor.slice(5, 7), 16)\n  ];\n};\n\nexport const hexToHue = (hexColor: string) => {\n  const [r, g, b] = fromHex(hexColor);\n  return rgbToHue(r, g, b);\n};\n", "import { sign } from \"./math/Common\";\nimport { hslaColor, rgbaColor } from \"./utils/Color\";\n\nconst CTX = Symbol(\"ctx\");\nconst CANVAS = Symbol(\"canvas\");\n\nexport class Canvas {\n  [CANVAS]: HTMLCanvasElement;\n  [CTX]: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this[CANVAS] = canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      throw Error(\"Unable to get 2d context\");\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    this[CTX] = ctx;\n\n    this[CTX].fillStyle = \"black\";\n    this[CTX].strokeStyle = \"black\";\n\n    this.width = this[CANVAS].width;\n    this.height = this[CANVAS].height;\n  }\n\n  /**\n   * Fill a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  fillRect(x: number, y: number, width: number, height: number) {\n    this[CTX].fillRect(x, y, width, height);\n  }\n\n  clear() {\n    this[CTX].clearRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Draw the outline of a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  strokeRect(x: number, y: number, width: number, height: number) {\n    this[CTX].strokeRect(x, y, width, height);\n  }\n\n  strokeRectInset(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    inset: number\n  ) {\n    this.strokeRect(\n      x + inset,\n      y + inset,\n      width - inset * 2,\n      height - inset * 2\n    );\n  }\n\n  /**\n   * Fill an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  fillEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].fill();\n  }\n\n  fillTriangle(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y + height);\n    this[CTX].lineTo(x + width, y + height);\n    this[CTX].lineTo(x + width / 2, y);\n    this[CTX].fill();\n  }\n\n  /**\n   * Outline an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  strokeEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].stroke();\n  }\n\n  fillDiamond(x: number, y: number, xRadius: number, yRadius: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y - yRadius);\n    this[CTX].lineTo(x + xRadius, y);\n    this[CTX].lineTo(x, y + yRadius);\n    this[CTX].lineTo(x - xRadius, y);\n    this[CTX].lineTo(x, y - yRadius);\n    this[CTX].fill();\n  }\n\n  fillOctagon(x: number, y: number, radius: number, cornerCut: number) {\n    const short = radius - cornerCut;\n    this[CTX].beginPath();\n    this[CTX].moveTo(x - short, y - radius);\n    this[CTX].lineTo(x + short, y - radius);\n    this[CTX].lineTo(x + radius, y - short);\n    this[CTX].lineTo(x + radius, y + short);\n    this[CTX].lineTo(x + short, y + radius);\n    this[CTX].lineTo(x - short, y + radius);\n    this[CTX].lineTo(x - radius, y + short);\n    this[CTX].lineTo(x - radius, y - short);\n    this[CTX].lineTo(x - short, y - radius);\n    this[CTX].fill();\n  }\n\n  outerCircleCorner(x: number, y: number, radius: number, startAngle: number) {\n    this[CTX].beginPath();\n    this[CTX].arc(x, y, radius, startAngle, startAngle + Math.PI / 2);\n    const toPoint = startAngle + Math.PI / 4;\n    this[CTX].lineTo(\n      x + sign(Math.cos(toPoint)) * radius,\n      y + sign(Math.sin(toPoint)) * radius\n    );\n    this[CTX].fill();\n  }\n\n  /**\n   * Draw a line on the canvas.\n   * @param {number} x0 The start x position\n   * @param {number} y0 The start y position\n   * @param {number} x1 The end x position\n   * @param {number} y1 The start y position\n   */\n  drawLine(x0: number, y0: number, x1: number, y1: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].lineTo(x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Draw a quadratic bezier curve on the canvas.\n   * @param {*} x0 The starting x position\n   * @param {*} y0 The starting y position\n   * @param {*} x1 The ending x position\n   * @param {*} y1 The ending y position\n   * @param {*} xControl The control point x position\n   * @param {*} yControl The control point y position\n   */\n  drawQuadratic(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    xControl: number,\n    yControl: number\n  ) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].quadraticCurveTo(xControl, yControl, x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Scale the canvas.\n   * @param {number} xScale\n   * @param {number} yScale\n   */\n  scale(xScale: number, yScale: number) {\n    this[CTX].scale(xScale, yScale);\n  }\n\n  /**\n   * Translate the canvas.\n   * @param {number} xOffset\n   * @param {number} yOffset\n   */\n  translate(xOffset: number, yOffset: number) {\n    this[CTX].translate(xOffset, yOffset);\n  }\n\n  translateCenterTo(xOffset: number, yOffset: number) {\n    this[CTX].translate(-xOffset + this.width / 2, -yOffset + this.height / 2);\n  }\n\n  setLineWidth(width: number) {\n    this[CTX].lineWidth = width;\n  }\n\n  get lineWidth() {\n    return this[CTX].lineWidth;\n  }\n\n  setLineDash(pattern: number[]) {\n    this[CTX].setLineDash(pattern);\n  }\n\n  /**\n   * Set the colour to be used for drawing on the canvas.\n   * @param {string} colorString The name of the color to be used\n   */\n  setColor(colorString: CanvasRenderingContext2D[\"fillStyle\"]) {\n    if (colorString === this[CTX].fillStyle) {\n      return;\n    }\n\n    this[CTX].fillStyle = colorString;\n    this[CTX].strokeStyle = colorString;\n  }\n\n  /**\n   * Set the current color via RGB.\n   * @param {number} red Red value from 0-255\n   * @param {number} green Green value from 0-255\n   * @param {number} blue Blue value from 0-255\n   * @param {number | undefined} alpha Alpha value from 0-255\n   */\n  setColorRGB(red: number, green: number, blue: number, alpha = 255) {\n    this.setColor(rgbaColor(red, green, blue, alpha));\n  }\n\n  /**\n   * Set the current color with hue, saturation, lightness and alpha.\n   * @param {number} hue Hue value from 0-359\n   * @param {number} saturation Saturation value from 0-1\n   * @param {number} lightness Lightness value from 0-1\n   * @param {number | undefined} alpha Alpha value from 0-1\n   */\n  setColorHSLA(hue: number, saturation: number, lightness: number, alpha = 1) {\n    this.setColor(hslaColor(hue, saturation, lightness, alpha));\n  }\n\n  createGradient(x0: number, y0: number, x1: number, y1: number) {\n    return this[CTX].createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(\n    x0: number,\n    y0: number,\n    r0: number,\n    x1: number,\n    y1: number,\n    r1: number\n  ) {\n    return this[CTX].createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  saveTransform() {\n    this[CTX].save();\n  }\n\n  restoreTransform() {\n    this[CTX].restore();\n  }\n\n  /**\n   * Draw another image to this canvas\n   * @param {Canvas} imageSource\n   * @param {number} sourceX\n   * @param {number} sourceY\n   * @param {number} sourceWidth\n   * @param {number} sourceHeight\n   * @param {number} destinationX\n   * @param {number} destinationY\n   * @param {number} destinationWidth\n   * @param {nubmer} destinationHeight\n   */\n  drawImage(\n    imageSource: Canvas | HTMLImageElement,\n    sourceX: number,\n    sourceY: number,\n    sourceWidth: number,\n    sourceHeight: number,\n    destinationX: number,\n    destinationY: number,\n    destinationWidth: number,\n    destinationHeight: number\n  ) {\n    let image: CanvasImageSource;\n    if (imageSource instanceof Canvas) {\n      image = imageSource[CANVAS];\n    } else if (imageSource instanceof Image) {\n      if (!imageSource.complete) {\n        return;\n      }\n      image = imageSource;\n    } else {\n      throw Error(\"Drawing something unmanageable\");\n    }\n\n    this[CTX].drawImage(\n      image,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destinationX,\n      destinationY,\n      destinationWidth,\n      destinationHeight\n    );\n  }\n\n  /**\n   * Create a Canvas from an id.\n   * @param {string} id The id attribute of the HTMLCanvasElement\n   */\n  static fromId(id: string) {\n    const canvas = document.getElementById(id);\n\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Could not find canvas with id: \"${id}\"`);\n    }\n\n    return new Canvas(canvas);\n  }\n\n  /**\n   * Create a new HTMLCanvasElement and use that as the basis for a Canvas.\n   */\n  static fromScratch(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n\n    return new Canvas(canvas);\n  }\n}\n", "export class Vector {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n\n    return this;\n  }\n\n  subtract(vector: Vector) {\n    this.x -= vector.x;\n    this.y -= vector.y;\n  }\n\n  multiply(factor: number) {\n    this.x *= factor;\n    this.y *= factor;\n\n    return this;\n  }\n\n  copy() {\n    return new Vector(this.x, this.y);\n  }\n\n  setFrom(otherVector: Vector) {\n    this.x = otherVector.x;\n    this.y = otherVector.y;\n  }\n\n  get magnitude(): number {\n    return Math.hypot(this.x, this.y);\n  }\n\n  setMagnitude(magnitude: number) {\n    if (this.x === 0 && this.y == 0) {\n      return;\n    }\n\n    this.multiply(magnitude / this.magnitude)\n  }\n\n  static add(a: Vector, b: Vector) {\n    return new Vector(a.x + b.x, a.y + b.y);\n  }\n\n  static diff(a: Vector, b: Vector) {\n    return new Vector(a.x - b.x, a.y - b.y);\n  }\n\n  static scale(vector: Vector, factor: number) {\n    return new Vector(vector.x * factor, vector.y * factor);\n  }\n\n  static sqrDist(a: Vector, b: Vector): number {\n    const xDiff = a.x - b.x;\n    const yDiff = a.y - b.y;\n    return xDiff * xDiff + yDiff * yDiff;\n  }\n\n  /**\n   * This is not actually manhattan distance. Consider refactoring.\n   */\n  static manhattanDist(a: Vector, b: Vector) {\n    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n  }\n\n  static dist(a: Vector, b: Vector) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  static lerp(v1: Vector, v2: Vector, t: number) {\n    return new Vector(v1.x * (1 - t) + v2.x * t, v1.y * (1 - t) + v2.y * t);\n  }\n}\n", "export interface GameEvent {\n  isExitEvent(): boolean;\n  isOpenMapEvent(): boolean;\n}\n\nexport type Direction = 'up' | 'left' | 'down' | 'right';\n\nexport class ExitEvent implements GameEvent {\n  roomKey: string;\n  direction: Direction;\n\n  constructor(roomKey: string, direction: Direction) {\n    this.roomKey = roomKey;\n    this.direction = direction;\n  }\n\n  isExitEvent(): boolean {\n    return true;\n  }\n\n  isOpenMapEvent(): boolean {\n    return false;\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { clamp, sign } from \"./Common\";\nimport { Vector } from \"./Vector\";\n\nexport class Circle {\n  position: Vector;\n  radius: number;\n\n  constructor(position: Vector, radius: number) {\n    this.position = position;\n    this.radius = radius;\n  }\n\n  /**\n   * Check if another circle intersects with this circle\n   * @param {Circle} otherCircle The circle to check intersection with\n   */\n  intersectsCircle(otherCircle: Circle) {\n    const radiusSum = this.radius + otherCircle.radius;\n    return (\n      Vector.sqrDist(this.position, otherCircle.position) <\n      radiusSum * radiusSum\n    );\n  }\n\n  /**\n   * Check if a point intersects with this circle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsVector(point: Vector) {\n    return Vector.sqrDist(this.position, point) < this.radius * this.radius;\n  }\n\n  /**\n   * Check if a rectangle intersects with this circle.\n   * @param {Rectangle} rectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(rectangle: Rectangle) {\n    // Find the co-ordinates of the closest point in the rectangle to the circle center.\n    const closestX = clamp(this.position.x, rectangle.x1, rectangle.x2);\n    const closestY = clamp(this.position.y, rectangle.y1, rectangle.y2);\n\n    // Find if the closest point in the rectangle overlaps with the circle.\n    return this.intersectsVector(new Vector(closestX, closestY));\n  }\n\n  /**\n   * Draw this circle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas) {\n    canvas.fillEllipse(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      this.radius\n    );\n  }\n}\n\nexport class Rectangle {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /**\n   * Check if a point intersects with this rectangle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsPoint(point: Vector) {\n    return (\n      this.x1 <= point.x &&\n      point.x <= this.x2 &&\n      this.y1 <= point.y &&\n      point.y <= this.y2\n    );\n  }\n\n  get width() {\n    return this.x2 - this.x1;\n  }\n\n  get height() {\n    return this.y2 - this.y1;\n  }\n\n  get midpoint() {\n    return new Vector((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n  }\n\n  xInRange(x: number): boolean {\n    return this.x1 <= x && x < this.x2;\n  }\n\n  yInRange(y: number): boolean {\n    return this.y1 <= y && y < this.y2;\n  }\n\n  /**\n   * Check if another rectangle intersects with this rectangle.\n   * @param {Rectangle} otherRectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(otherRectangle: Rectangle) {\n    return (\n      otherRectangle.x1 <= this.x2 &&\n      this.x1 <= otherRectangle.x2 &&\n      otherRectangle.y1 <= this.y2 &&\n      this.y1 <= otherRectangle.y2\n    );\n  }\n\n  /**\n   * Compute the smallest vector in the reverse direction to movement to\n   * uncollide with a given rectangle.\n   * @param {Circle} circle\n   */\n  uncollideCircle(circle: Circle) {\n    const closestX = clamp(circle.position.x, this.x1, this.x2);\n    const closestY = clamp(circle.position.y, this.y1, this.y2);\n\n    const p0 = new Vector(closestX, closestY);\n    const pToCenter = Vector.diff(circle.position, p0);\n\n    const distFromCenter = pToCenter.magnitude || 1;\n\n    if (distFromCenter >= circle.radius) {\n      const circleDistToMyCenter = Vector.diff(circle.position, this.midpoint);\n      const horizontalDistance =\n        this.width / 2 - Math.abs(circleDistToMyCenter.x);\n      const verticalDistance =\n        this.height / 2 - Math.abs(circleDistToMyCenter.y);\n\n      // Shortest way out is horizontally\n      if (horizontalDistance < verticalDistance) {\n        return new Vector(\n          (horizontalDistance + circle.radius) * sign(circleDistToMyCenter.x),\n          0\n        );\n      } else {\n        return new Vector(\n          0,\n          (verticalDistance + circle.radius) * sign(circleDistToMyCenter.y)\n        );\n      }\n    }\n\n    return Vector.scale(\n      pToCenter,\n      (circle.radius - distFromCenter) / distFromCenter\n    );\n  }\n\n  /**\n   * Draw this rectangle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas, outset = 0) {\n    canvas.fillRect(\n      this.x1 - outset,\n      this.y1 - outset,\n      this.width + outset * 2,\n      this.height + outset * 2\n    );\n  }\n\n  stroke(canvas: Canvas, inset = 0) {\n    canvas.strokeRectInset(this.x1, this.y1, this.width, this.height, inset);\n  }\n\n  inset(insetBy: number) {\n    return new Rectangle(\n      this.x1 + insetBy,\n      this.y1 + insetBy,\n      this.x2 - insetBy,\n      this.y2 - insetBy\n    );\n  }\n\n  static widthForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x, y, x + width, y + height);\n  }\n\n  static centerForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x - width, y - height, x + width, y + height);\n  }\n\n  static aroundPoint(point: Vector, halfWidth: number, halfHeight: number) {\n    return new Rectangle(\n      point.x - halfWidth,\n      point.y - halfHeight,\n      point.x + halfWidth,\n      point.y + halfHeight\n    );\n  }\n\n  // Creates a rectangle that overlaps all of the provided ones\n  static merged(rectangles: Rectangle[]) {\n    const [x1, y1, x2, y2] = rectangles.reduce<\n      [number, number, number, number]\n    >(\n      ([x1, y1, x2, y2], rect) => [\n        Math.min(rect.x1, x1),\n        Math.min(rect.y1, y1),\n        Math.max(rect.x2, x2),\n        Math.max(rect.y2, y2),\n      ],\n      [Infinity, Infinity, -Infinity, -Infinity]\n    );\n\n    return new Rectangle(x1, y1, x2, y2);\n  }\n}\n\nexport class Octagon {\n  center: Vector;\n  radius: number;\n  cornerCut: number;\n\n  constructor(center: Vector, radius: number, cornerCut: number) {\n    this.center = center;\n    this.radius = radius;\n    this.cornerCut = cornerCut;\n  }\n\n  draw(canvas: Canvas) {\n    canvas.fillOctagon(this.center.x, this.center.y, this.radius, this.cornerCut);\n  }\n\n  intersectsRectangle(rectangle: Rectangle) {\n    const approximate = Rectangle.centerForm(this.center.x, this.center.y, this.radius, this.radius);\n    \n    if (!approximate.intersectsRectangle(rectangle)) {\n      return false;\n    }\n\n    const rectMid = rectangle.midpoint;\n\n    const centerManhattanDistance = Math.abs(rectMid.x - this.center.x) + Math.abs(rectMid.y - this.center.y);\n\n    return centerManhattanDistance < (rectangle.width + rectangle.height) / 2 + this.radius * 2 - this.cornerCut;\n  }\n\n  intersectsBy(rectangle: Rectangle) {\n    const mid = rectangle.midpoint;\n    const xDiff = Math.abs(this.center.x - mid.x);\n    const yDiff = Math.abs(this.center.y - mid.y);\n\n    return Math.max(0, Math.min(\n      this.radius + rectangle.width / 2 - xDiff,\n      this.radius + rectangle.height / 2 - yDiff,\n    ));\n  }\n\n  collideRectangle(rectangle: Rectangle) {\n    const rectMid = rectangle.midpoint;\n\n    const xDiff = Math.abs(this.center.x - rectMid.x);\n    const yDiff = Math.abs(this.center.y - rectMid.y);\n\n    if (xDiff >= this.radius + rectangle.width / 2 || yDiff >= this.radius + rectangle.height / 2) {\n      // Definitely no overlap\n      return;\n    }\n\n    const manhattanIdeal = (rectangle.width + rectangle.height) / 2 + this.radius * 2 - this.cornerCut;\n\n    if (xDiff + yDiff >= manhattanIdeal) {\n      // In corners, no overlap\n      return;\n    }\n\n    if (!this.intersectsRectangle(rectangle)) {\n      console.error('Collision fuck up');\n    }\n\n    if (yDiff < this.radius - this.cornerCut + rectangle.height / 2) {\n      // Face collision - horizontal\n      const xDist = rectangle.width / 2 + this.radius;\n      this.center.x = rectMid.x + xDist * sign(this.center.x - rectMid.x);\n      return;\n    }\n\n    if (xDiff < this.radius - this.cornerCut + rectangle.width / 2) {\n      // Face collision - vertical\n      const yDist = rectangle.height / 2 + this.radius;\n      this.center.y = rectMid.y + yDist * sign(this.center.y - rectMid.y);\n      return;\n    }\n\n    // Diagonal collision\n    const manhattanOverlap = manhattanIdeal - (xDiff + yDiff);\n\n    this.center.x += manhattanOverlap / 2 * sign(this.center.x - rectMid.x);\n    this.center.y += manhattanOverlap / 2 * sign(this.center.y - rectMid.y);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { Input } from \"../constants/Keys\";\nimport { GRID_SIZE, PLAYER_CORNER, PLAYER_REACH, PLAYER_SIZE } from \"../constants/WorldConstants\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { floorTo } from \"../math/Common\";\nimport { Octagon } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { Room } from \"./Room\";\n\nconst PLAYER_MAX_SPEED = 130;\nconst PLAYER_ACCEL = PLAYER_MAX_SPEED / 1.2;\n\nexport class Player {\n  velocity: Vector;\n  collider: Octagon;\n  direction: Vector | null;\n\n  constructor(position: Vector) {\n    this.collider = new Octagon(position, PLAYER_SIZE, PLAYER_CORNER);\n\n    this.velocity = new Vector(0, 0);\n    this.direction = new Vector(0, -1);\n  }\n\n  getCursorCell() {\n    const cursor = this.direction;\n\n    if (!cursor) {\n      return null;\n    }\n\n    return new Vector(floorTo(cursor.x, GRID_SIZE), floorTo(cursor.y, GRID_SIZE));\n  }\n\n  onInput(input: InputEvent, room: Room) {\n    if (input.isForKey(Input.Interact) || input.isClick()) {\n      const cursorCell = this.getCursorCell();\n      if (cursorCell) {\n        room.interactOnCell(cursorCell);\n      }\n    }\n  }\n\n  update(deltaTime: number, inputState: InputState, room: Room) {\n    const inputX = inputState.getHorizontalAxis();\n    const inputY = inputState.getVerticalAxis();\n    let acceleration = new Vector(inputX, inputY).multiply(PLAYER_ACCEL);\n\n    this.velocity.add(acceleration.multiply(1));\n    const totalVel = this.velocity.magnitude;\n\n    // this.direction = this.velocity.copy();\n    // this.direction.setMagnitude(GRID_SIZE * 1.0);\n\n    if (totalVel > PLAYER_MAX_SPEED) {\n      this.velocity.multiply(PLAYER_MAX_SPEED / totalVel);\n    }\n\n    if (acceleration.x === 0 && acceleration.y === 0) {\n      this.velocity.multiply(0.5);\n    }\n\n    const off = this.velocity.copy().multiply(deltaTime);\n\n    this.collider.center.add(off);\n    \n    for (const block of room.blocks) {\n      this.collider.collideRectangle(block);\n    }\n\n    // this.direction.add(this.collider.center);\n\n    this.direction = Vector.add(inputState.mousePosition, room.camera);\n\n    if (Vector.dist(this.direction, this.collider.center) > PLAYER_REACH) {\n      this.direction = null;\n    }\n  }\n\n  collideWithBlock() {\n\n  }\n\n  draw(canvas: Canvas) {\n    const cursorCell = this.getCursorCell();\n\n    if (cursorCell) {\n      canvas.setColor(\"#0005\");\n      canvas.setLineWidth(2);\n\n      canvas.strokeRect(cursorCell.x, cursorCell.y, GRID_SIZE, GRID_SIZE);\n    }\n\n    canvas.setColor(\"green\");\n    this.collider.draw(canvas);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { GRID_SIZE } from \"../constants/WorldConstants\";\nimport { Direction, ExitEvent } from \"../game-modes/GameEvent\";\nimport { PlayMode } from \"../game-modes/PlayMode\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { floorTo } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { Player } from \"./Player\";\n\nconst DOORWAY_SIZE = GRID_SIZE * 2;\n\nconst BOUNDARY = 50;\n\nconst randint = (max: number) => Math.floor(Math.random() * max);\n\nexport class Room {\n  key: string;\n  width: number;\n  height: number;\n  collider: Rectangle;\n\n  player: Player;\n  camera: Vector;\n\n  visited = false;\n  backgroundDirty = true;\n\n  blocks: Rectangle[];\n  exits: [Rectangle, Direction][];\n\n  color: string;\n\n  constructor(key: string, width: number, height: number) {\n    this.color = `hsl(${randint(360)}, ${randint(20) + 50}%, ${randint(30) + 60}%)`;\n\n    this.key = key;\n    this.width = floorTo(width, 2 * GRID_SIZE);\n    this.height = floorTo(height, 2 * GRID_SIZE);\n\n    this.collider = Rectangle.widthForm(0, 0, this.width, this.height);\n\n    this.camera = new Vector(this.width / 2, this.height / 2);\n    this.player = new Player(this.camera.copy());\n\n    this.blocks = [];\n    for (let i = GRID_SIZE; i < this.width - GRID_SIZE; i += GRID_SIZE) {\n      for (let j = GRID_SIZE; j < this.height - GRID_SIZE; j += GRID_SIZE) {\n        if (Math.random() < 0.06) {\n          this.blocks.push(new Rectangle(i, j, i + GRID_SIZE, j + GRID_SIZE));\n        }\n      }\n    }\n\n    this.blocks.push(...[\n      new Rectangle(-BOUNDARY, -BOUNDARY, this.width / 2 - DOORWAY_SIZE, 0),\n      new Rectangle(this.width / 2 + DOORWAY_SIZE, -BOUNDARY, this.width + BOUNDARY, 0),\n      new Rectangle(this.width, -BOUNDARY, this.width + BOUNDARY, this.height / 2 - DOORWAY_SIZE),\n      new Rectangle(this.width, this.height / 2 + DOORWAY_SIZE, this.width + BOUNDARY, this.height + BOUNDARY),\n      new Rectangle(this.width / 2 + DOORWAY_SIZE, this.height, this.width + BOUNDARY, this.height + BOUNDARY),\n      new Rectangle(-BOUNDARY, this.height, this.width / 2 - DOORWAY_SIZE, this.height + BOUNDARY),\n      new Rectangle(-BOUNDARY, this.height / 2 + DOORWAY_SIZE, 0, this.height + BOUNDARY),\n      new Rectangle(-BOUNDARY, -BOUNDARY, 0, this.height / 2 - DOORWAY_SIZE),\n    ]);\n\n    this.exits = [\n      [Rectangle.widthForm(this.width / 2 - DOORWAY_SIZE, -BOUNDARY, DOORWAY_SIZE * 2, BOUNDARY), 'up'],\n      [Rectangle.widthForm(-BOUNDARY, this.height / 2 - DOORWAY_SIZE, BOUNDARY, DOORWAY_SIZE * 2), 'left'],\n      [Rectangle.widthForm(this.width / 2 - DOORWAY_SIZE, this.height, DOORWAY_SIZE * 2, BOUNDARY), 'down'],\n      [Rectangle.widthForm(this.width, this.height / 2 - DOORWAY_SIZE, BOUNDARY, DOORWAY_SIZE * 2), 'right'],\n    ];\n  }\n\n  start() {\n    this.visited = true;\n    this.backgroundDirty = true;\n  }\n\n  update(deltaTime: number, inputState: InputState, mode: PlayMode) {\n    // ...\n    this.player.update(deltaTime, inputState, this);\n\n    const exit = this.exits.find(([exit]) => exit.intersectsPoint(this.player.collider.center));\n\n    if (exit) {\n      mode.onLevelEvent(new ExitEvent(this.key, exit[1]));\n    }\n  }\n\n  onInput(input: InputEvent) {\n    // waddap\n    this.player.onInput(input, this);\n  }\n\n  interactOnCell(position: Vector) {\n    let removedIndex = -1;\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      if (block.x1 === position.x && block.y1 === position.y && block.width === GRID_SIZE && block.height === GRID_SIZE) {\n        removedIndex = index;\n        break;\n      }\n    }\n\n    if (removedIndex !== -1) {\n      this.backgroundDirty = true;\n      this.blocks.splice(removedIndex, 1);\n      return;\n    } else {\n      const newRect = Rectangle.widthForm(position.x, position.y, GRID_SIZE, GRID_SIZE);\n\n      if (\n        !this.collider.intersectsPoint(newRect.midpoint) ||\n        this.exits.some(([exit]) => exit.intersectsRectangle(newRect))\n      ) {\n        return;\n      }\n\n      const overlap = this.player.collider.intersectsBy(newRect);\n\n      if (overlap < 5) {\n        this.backgroundDirty = true;\n        this.blocks.push(newRect);\n      } else {\n        // Do nothing\n      }\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    screenManager.setCamera(this.camera.copy().add(new Vector(BOUNDARY, BOUNDARY)));\n\n    screenManager.uiCanvas.clear();\n\n    if (this.backgroundDirty) {\n      this.backgroundDirty = false;\n\n      const canvas = screenManager.staticWorldCanvas;\n      canvas.clear();\n\n      canvas.translate(BOUNDARY, BOUNDARY);\n\n      canvas.setColor(\"black\");\n      canvas.setLineWidth(5);\n      canvas.strokeRect(0, 0, this.width, this.height);\n\n      canvas.setColor(this.color);\n      canvas.fillRect(0, 0, this.width, this.height);\n\n      canvas.setColor(\"gray\");\n      this.blocks.forEach((block) => block.draw(canvas));\n\n      canvas.translate(-BOUNDARY, -BOUNDARY);\n    }\n    \n    const canvas = screenManager.dynamicWorldCanvas;\n    canvas.clear();\n\n    canvas.translate(BOUNDARY, BOUNDARY);\n\n    this.player.draw(canvas);\n\n    canvas.translate(-BOUNDARY, -BOUNDARY);\n  }\n\n  drawForMap(canvas: Canvas) {\n    const INSET = 4;\n\n    const insetRect = (insetBy: number) =>\n      canvas.fillRect(\n        insetBy * INSET,\n        insetBy * INSET,\n        canvas.width - insetBy * INSET * 2,\n        canvas.height - insetBy * INSET * 2,\n      );\n\n    canvas.setColor(\"grey\");\n    insetRect(1);\n\n    canvas.setColor(this.color);\n    insetRect(2);\n\n    // canvas.scale(1/GRID_SIZE, 1/GRID_SIZE);\n    // canvas.setColor(\"grey\");\n    // this.blocks.forEach(block => block.draw(canvas));\n    // canvas.scale(GRID_SIZE, GRID_SIZE);\n  }\n\n  enterFrom(event: ExitEvent) {\n    const BUFF = 10;\n    const map = {\n      up: new Vector(this.width / 2, this.height - BUFF),\n      right: new Vector(BUFF, this.height / 2),\n      down: new Vector(this.width / 2, BUFF),\n      left: new Vector(this.width - BUFF, this.height / 2),\n    }\n\n    this.player.collider.center = map[event.direction];\n\n    this.start();\n  }\n}\n", "import { Direction, ExitEvent } from \"../game-modes/GameEvent\";\nimport { Vector } from \"../math/Vector\";\nimport { Room } from \"./Room\";\n\nexport const parseKey = (s: string): Vector => {\n  const [x, y] = s.split(\",\").map(x => parseInt(x));\n\n  return new Vector(x, y);\n};\n\nexport const encodeKey = (v: Vector): string => {\n  return `${v.x},${v.y}`;\n};\n\nconst directionMap: Record<Direction, Vector> = {\n  up: new Vector(0, -1),\n  down: new Vector(0, 1),\n  left: new Vector(-1, 0),\n  right: new Vector(1, 0),\n};\n\nexport class RoomWeb {\n  currentRoom: Room;\n\n  map: Map<string, Room>;\n\n  rooms: Room[];\n\n  constructor() {\n    this.map = new Map();\n    this.rooms = [];\n    \n    this.currentRoom = this.createRoom(new Vector(0, 0));\n  }\n\n  createRoom(position: Vector) {\n    const newRoom = new Room(encodeKey(position), 900, 600);\n    this.map.set(encodeKey(position), newRoom);\n    this.rooms.push(newRoom);\n\n    return newRoom;\n  }\n\n  currentRoomPosition() {\n    return parseKey(this.currentRoom.key);\n  }\n\n  navigate(event: ExitEvent) {\n    const { roomKey, direction } = event;\n\n    const nextPosition = Vector.add(parseKey(roomKey), directionMap[direction]);\n    const nextKey = encodeKey(nextPosition)\n\n    const currentRoom = this.map.get(roomKey);\n\n    if (!currentRoom) {\n      console.error(\"Exited a room that does not exist!\", roomKey, Array.from(this.map.keys()));\n      return;\n    }\n\n    const nextRoom = this.map.get(nextKey);\n    if (nextRoom) {\n      this.currentRoom = nextRoom;\n    } else {\n      this.currentRoom = this.createRoom(nextPosition);\n    }\n\n    this.currentRoom.enterFrom(event);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { GameModeManager } from \"../GameModeManager\";\nimport {\n  ClickEvent,\n  InputEvent,\n  InputState,\n  ScrollEvent,\n} from \"../InputManager\";\nimport { Room } from \"../room/Room\";\nimport { clamp } from \"../math/Common\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { PlayMode } from \"./PlayMode\";\nimport { parseKey } from \"../room/RoomWeb\";\nimport { GRID_SIZE, WORLD_GRID_HEIGHT, WORLD_GRID_WIDTH } from \"../constants/WorldConstants\";\n\nconst DEBUG_SHOW_ALL_ROOMS = document.location.toString().includes(\"localhost\");\n\nconst MAX_ZOOM = 0.5;\nconst MIN_ZOOM = 0.05;\nconst ZOOM_SPEED = 0.001;\n\nconst ZOOM_LEVELS = [0.05, 0.1, 0.15, 0.2, 0.3, 0.5];\nconst ZOOMS_REVERSED = ZOOM_LEVELS.slice();\nZOOMS_REVERSED.reverse();\n\nconst MAP_PLAYER_SCALE = 60;\n\nconst MAP_CANVAS_SCALE = 10;\n\ninterface MapInteractible {\n  room: Room;\n  interactible: unknown;\n  isHovered: boolean;\n  position: Vector;\n}\n\nexport class MapMode {\n  gameModeManager: GameModeManager;\n  playMode: PlayMode;\n  cameraPosition: Vector;\n  zoom: number;\n\n  mousePosition: Vector;\n  isClicked: boolean;\n\n  canvasW: number;\n  canvasH: number;\n\n  roomCanvasMap: Map<string, Canvas>;\n  drawIcons: MapInteractible[];\n\n  constructor(gameModeManager: GameModeManager) {\n    this.gameModeManager = gameModeManager;\n    this.playMode = gameModeManager.playMode;\n    this.cameraPosition = new Vector(0, 0);\n    this.setCameraPos();\n    this.zoom = MAX_ZOOM;\n\n    this.mousePosition = new Vector(0, 0);\n    this.isClicked = false;\n\n    this.canvasW = 0;\n    this.canvasH = 0;\n\n    this.roomCanvasMap = new Map<string, Canvas>();\n    this.drawIcons = [];\n  }\n\n  setCameraPos() {\n    const currentRoom = this.playMode.roomWeb.currentRoom;\n    this.cameraPosition = Vector.add(\n      this.getRoomPosition(currentRoom),\n      new Vector(currentRoom.width / 2, currentRoom.height / 2),\n    );\n  }\n\n  onStart() {\n    this.setCameraPos();\n    this.mousePosition = new Vector(0, 0);\n    this.isClicked = false;\n    this.predrawRooms();\n    this.drawIcons = this.getIconsToShow();\n  }\n\n  getIconsToShow(): MapInteractible[] {\n    const icons: MapInteractible[] = [];\n    // for (const room of this.playMode.roomWeb.rooms) {\n    //   for (const entity of room.entities) {\n    //     if (interactible.showAsMapIcon) {\n    //       icons.push({\n    //         room,\n    //         entity,\n    //         position: Vector.add(level.worldPosition, interactible.position),\n    //         isHovered: false,\n    //       });\n    //     }\n    //   }\n    // }\n\n    return icons;\n  }\n\n  predrawRooms() {\n    for (const room of this.playMode.roomWeb.rooms) {\n      if (!DEBUG_SHOW_ALL_ROOMS && !room.visited) {\n        continue;\n      }\n\n      const canvas = this.roomCanvasMap.get(room.key) ||\n        Canvas.fromScratch(\n          room.width * MAX_ZOOM / GRID_SIZE * MAP_CANVAS_SCALE,\n          room.height * MAX_ZOOM / GRID_SIZE * MAP_CANVAS_SCALE,\n        );\n\n      canvas.saveTransform();\n      canvas.scale(MAX_ZOOM, MAX_ZOOM);\n      room.drawForMap(canvas);\n      canvas.restoreTransform();\n\n      this.roomCanvasMap.set(room.key, canvas);\n    }\n  }\n\n  toWorldPosition(position: Vector) {\n    return Vector.add(\n      Vector.scale(\n        Vector.diff(position, new Vector(this.canvasW / 2, this.canvasH / 2)),\n        1 / this.zoom\n      ),\n      this.cameraPosition\n    );\n  }\n\n  update(_deltaTime: number, inputState: InputState) {\n    const currentWorldPos = this.toWorldPosition(inputState.mousePosition);\n\n    let found: MapInteractible | undefined = undefined;\n    for (const icon of this.drawIcons) {\n      // Only allow one icon to be hovered\n      if (found) {\n        icon.isHovered = false;\n        continue;\n      }\n\n      if (Vector.sqrDist(icon.position, currentWorldPos) < 32) {\n        icon.isHovered = true;\n        found = icon;\n      } else {\n        icon.isHovered = false;\n      }\n    }\n\n    if (inputState.isLeftClicking() && this.isClicked) {\n      this.cameraPosition.subtract(\n        Vector.diff(currentWorldPos, this.mousePosition)\n      );\n    } else {\n      this.isClicked = false;\n    }\n  }\n\n  onInput(inputEvent: InputEvent) {\n    // Do nothing\n    if (inputEvent.isClick()) {\n      // const hoveredIcon = this.drawIcons.find((icon) => icon.isHovered);\n\n      // const isAPortalActive = this.playMode.currentLevel.interactingWith instanceof PortalInteractible;\n\n      // if (hoveredIcon && isAPortalActive) {\n      //   const event = hoveredIcon.interactible.clickedOnMap();\n\n      //   if (event) {\n      //     event.process(this.playMode);\n      //     this.gameModeManager.switchToMode(this.playMode);\n      //   }\n      // }\n\n      const event = inputEvent as ClickEvent;\n      if (!event.isRightClick()) {\n        this.mousePosition = this.toWorldPosition(event.position);\n        this.isClicked = true;\n      }\n    } else if (inputEvent.isScroll()) {\n      const scroll = inputEvent as ScrollEvent;\n      if (scroll.discrete) {\n        if (scroll.delta > 0) {\n          this.zoom = ZOOM_LEVELS.find(x => x > this.zoom) || MAX_ZOOM;\n        } else {\n          this.zoom = ZOOMS_REVERSED.find(x => x < this.zoom) || MIN_ZOOM;\n        }\n      } else {\n        this.zoom = clamp(this.zoom + scroll.delta * -ZOOM_SPEED, MIN_ZOOM, MAX_ZOOM);\n      }\n    }\n  }\n\n  getRoomPosition(room: Room) {\n    const { x, y } = parseKey(room.key);\n\n    return new Vector(x * WORLD_GRID_WIDTH, y * WORLD_GRID_HEIGHT);\n  }\n\n  draw(screenManager: ScreenManager) {\n    const currentRoom = this.playMode.roomWeb.currentRoom;\n\n    const canvas = screenManager.uiCanvas;\n    this.canvasW = canvas.width;\n    this.canvasH = canvas.height;\n\n    canvas.setColor(\"black\");\n    canvas.fillRect(0, 0, canvas.width, canvas.height);\n\n    canvas.saveTransform();\n    canvas.translate(canvas.width / 2, canvas.height / 2);\n\n    canvas.scale(this.zoom, this.zoom);\n\n    canvas.translate(-this.cameraPosition.x, -this.cameraPosition.y);\n\n    const currentPlayer = currentRoom.player;\n\n    for (const room of this.playMode.roomWeb.rooms) {\n      const roomCanvas = this.roomCanvasMap.get(room.key);\n      if ((!DEBUG_SHOW_ALL_ROOMS && !room.visited) || !roomCanvas) {\n        continue;\n      }\n\n      const position = this.getRoomPosition(room);\n\n      canvas.drawImage(\n        roomCanvas,\n        0,\n        0,\n        roomCanvas.width,\n        roomCanvas.height,\n        position.x,\n        position.y,\n        room.width * 2,\n        room.height * 2,\n      );\n    }\n\n    if (currentPlayer) {\n      const worldPosition = this.getRoomPosition(currentRoom);\n      const offset = Vector.add(worldPosition, new Vector(currentRoom.width / 2, currentRoom.height / 2));\n      canvas.translate(offset.x, offset.y);\n\n      canvas.setLineWidth(8);\n      canvas.setLineDash([]);\n\n      canvas.setColor(\"white\");\n      canvas.fillEllipse(0, 0, MAP_PLAYER_SCALE, MAP_PLAYER_SCALE);\n      canvas.setColor(\"black\");\n      canvas.strokeEllipse(0, 0, MAP_PLAYER_SCALE, MAP_PLAYER_SCALE);\n\n      canvas.translate(-offset.x, -offset.y);\n    }\n\n    // const zoom = this.zoom / 2;\n\n    // for (const { room, interactible, isHovered } of this.drawIcons) {\n    //   const worldPosition = this.getRoomPosition(room);\n    //   const offset = Vector.add(worldPosition, interactible.position);\n    //   canvas.translate(offset.x, offset.y);\n    //   const innerZoom = isHovered ? zoom * 0.8 : zoom;\n    //   canvas.scale(1 / innerZoom, 1 / innerZoom);\n\n    //   interactible.drawAsMapIcon(canvas, room);\n\n    //   canvas.scale(innerZoom, innerZoom);\n    //   canvas.translate(-offset.x, -offset.y);\n    // }\n\n    canvas.restoreTransform();\n  }\n}", "// import { LevelManager } from \"../level/LevelManager\";\nimport { Room } from \"../room/Room\";\n// import { ExitEvent, LevelEvent } from \"../level/LevelEvent\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { GameModeManager } from \"../GameModeManager\";\nimport { GRID_SIZE } from \"../constants/WorldConstants\";\nimport { floorTo } from \"../math/Common\";\nimport { RoomWeb } from \"../room/RoomWeb\";\nimport { ExitEvent, GameEvent } from \"./GameEvent\";\n\nexport class PlayMode {\n  gameModeManager: GameModeManager;\n\n  roomWeb: RoomWeb;\n\n  constructor(gameModeManager: GameModeManager) {\n    this.gameModeManager = gameModeManager;\n\n    this.roomWeb = new RoomWeb();\n    this.startLevel(this.roomWeb.currentRoom);\n  }\n\n  startLevel(room: Room) {\n    room.start(/* this */);\n  }\n\n  onStart() {\n    this.roomWeb.currentRoom.start();\n  }\n\n  onLevelEvent(event: GameEvent) {\n    if (event.isExitEvent()) {\n      const exit = (event as ExitEvent);\n      this.roomWeb.navigate(exit);\n    } else if (event.isOpenMapEvent()) {\n      // this.gameModeManager.switchToMode(this.gameModeManager.mapMode);\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {object} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.roomWeb.currentRoom.update(deltaTime, inputState, this);\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.roomWeb.currentRoom.onInput(input);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager) {\n    this.roomWeb.currentRoom.draw(screenManager);\n  }\n}\n", "import { Input } from \"./constants/Keys\";\nimport { IS_MOBILE } from \"./constants/ScreenConstants\";\nimport { MapMode } from \"./game-modes/MapMode\";\n// import { MapMode } from \"./game-modes/MapMode\";\nimport { PlayMode } from \"./game-modes/PlayMode\";\nimport { InputEvent, InputState } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\ninterface Mode {\n  update(deltaTime: number, inputState: InputState): void;\n  onInput(inputEvent: InputEvent): void;\n  draw(screenManager: ScreenManager): void;\n  onStart(): void;\n}\n\nconst ALL_SECTIONS = [\n  \"horizontal-movement\",\n  \"vertical-movement\",\n  \"map-c\",\n  \"exit-c\",\n  \"zoom-c\",\n];\n\nexport class GameModeManager {\n  playMode: PlayMode;\n  mapMode: MapMode;\n\n  currentMode: Mode;\n\n  constructor() {\n    this.playMode = new PlayMode(this);\n    this.mapMode = new MapMode(this);\n\n    // Probably needs to initially be a menu mode eventually, or some dev-mode tooling\n    this.currentMode = this.playMode;\n    this.playMode.onStart();\n  }\n\n  /**\n   * Update the current gamemode.\n   * @param {number} deltaTime The time that has elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentMode.update(deltaTime, inputState);\n  }\n\n  switchToMode(mode: Mode) {\n    this.currentMode = mode;\n    mode.onStart();\n  }\n\n  /**\n   * Process an input event\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    let consumed = false;\n    if (this.currentMode === this.playMode) {\n      if (input.isForKey(Input.Map)) {\n        consumed = true;\n        this.switchToMode(this.mapMode);\n      }\n    } else if (this.currentMode === this.mapMode) {\n      if (input.isForKey(Input.Escape) || input.isForKey(Input.Map)) {\n        consumed = false;\n        this.switchToMode(this.playMode);\n      }\n    }\n\n    if (!consumed) {\n      this.currentMode.onInput(input);\n    }\n  }\n\n  /**\n   * Draw the current gamemode.\n   * @param {ScreenManager} screenManager The screenManager object.\n   */\n  draw(screenManager: ScreenManager) {\n    this.currentMode.draw(screenManager);\n  }\n\n  enableSections(sectionIds: string[]) {\n    if (!IS_MOBILE) {\n      return;\n    }\n\n    for (const section of ALL_SECTIONS) {\n      document.getElementById(section)?.classList.add(\"hidden\");\n    }\n\n    for (const section of sectionIds) {\n      document.getElementById(section)?.classList.remove(\"hidden\");\n    }\n  }\n}\n", "import { Input } from \"./constants/Keys\";\nimport {\n  ON_SCREEN_CANVAS_WIDTH,\n  IS_MOBILE,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nconst KEY_MAP: Record<string, Key> = {\n  \" \": Input.Jump,\n  Escape: Input.Escape,\n  KeyW: Input.Up,\n  KeyA: Input.Left,\n  KeyS: Input.Down,\n  KeyD: Input.Right,\n  KeyE: Input.Interact,\n  KeyM: Input.Map,\n};\n\ntype ValueOf<T> = T[keyof T];\n\ntype Key = ValueOf<typeof Input>;\n\ntype KeyMap = Record<Key, boolean>;\n\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return window.TouchEvent && event instanceof TouchEvent;\n}\n\nexport class InputState {\n  keyMap: KeyMap;\n  mousePosition: Vector;\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  constructor(\n    keyMap: KeyMap,\n    mousePosition: Vector,\n    leftClicking: boolean = false,\n    rightClicking: boolean = false\n  ) {\n    this.keyMap = keyMap;\n    this.mousePosition = mousePosition;\n    this.leftClicking = leftClicking;\n    this.rightClicking = rightClicking;\n  }\n\n  /**\n   * Check the current value for the horizontal axis input.\n   * @return {number} a value from -1 to 1.\n   */\n  getHorizontalAxis() {\n    return +!!this.keyMap[Input.Right] - +!!this.keyMap[Input.Left];\n  }\n\n  getVerticalAxis() {\n    return +!!this.keyMap[Input.Down] - +!!this.keyMap[Input.Up];\n  }\n\n  /**\n   * Checks whether an input is currently pressed.\n   * @param {Input} input\n   */\n  isPressed(input: Key) {\n    return !!this.keyMap[input];\n  }\n\n  isLeftClicking() {\n    return this.leftClicking;\n  }\n\n  isRightClicking() {\n    return this.rightClicking;\n  }\n\n  static empty() {\n    return new InputState({}, new Vector(0, 0));\n  }\n}\n\nexport class InputEvent {\n  constructor() {}\n\n  isForKey(_key: Key) {\n    return false;\n  }\n\n  isClick() {\n    return false;\n  }\n\n  isScroll() {\n    return false;\n  }\n}\n\nexport class KeyPressEvent extends InputEvent {\n  input: Key;\n\n  constructor(input: Key) {\n    super();\n    this.input = input;\n  }\n\n  isForKey(key: Key) {\n    return key === this.input;\n  }\n}\n\nexport class ClickEvent extends InputEvent {\n  position: Vector;\n  isRight: boolean;\n\n  constructor(position: Vector, isRightClick: boolean) {\n    super();\n    this.position = position;\n    this.isRight = isRightClick;\n  }\n\n  isClick() {\n    return true;\n  }\n\n  isRightClick() {\n    return this.isRight;\n  }\n}\n\nexport class ScrollEvent extends InputEvent {\n  delta: number;\n  discrete: boolean;\n\n  constructor(delta: number, discrete?: boolean) {\n    super();\n    this.delta = delta;\n    this.discrete = !!discrete;\n  }\n\n  isScroll() {\n    return true;\n  }\n}\n\nexport class InputManager {\n  listener: (inputEvent: InputEvent) => void;\n\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  isButtonDown: KeyMap;\n  mousePosition: Vector;\n\n  canvas: HTMLCanvasElement;\n\n  constructor(listener: (inputEvent: InputEvent) => void) {\n    this.leftClicking = false;\n    this.rightClicking = false;\n\n    this.isButtonDown = {};\n    this.listener = listener;\n    this.mousePosition = new Vector(0, 0);\n\n    this.canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  }\n\n  /**\n   * Set up event listeners.\n   */\n  init() {\n    const onKeyEvent = (symbol: Key) => {\n      if (this.listener) {\n        this.listener(new KeyPressEvent(symbol));\n      }\n    };\n\n    document.addEventListener(\"keydown\", (e) => {\n      const key = e.code;\n\n      if (e.repeat) {\n        return;\n      }\n      const symbol = KEY_MAP[key];\n      if (!symbol) {\n        return;\n      }\n\n\n      this.isButtonDown[symbol] = true;\n      onKeyEvent(symbol);\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const key = e.code;\n\n      const symbol = KEY_MAP[key];\n      if (!symbol) {\n        return;\n      }\n\n\n      this.isButtonDown[symbol] = false;\n    });\n\n    this.canvas.addEventListener(IS_MOBILE ? \"touchmove\" : \"mousemove\", (event) => {\n      this.mousePosition = this.toCanvasPosition(event);\n    });\n\n    this.canvas.addEventListener(IS_MOBILE ? \"touchstart\" : \"mousedown\", (event) => {\n      if (IS_MOBILE) {\n        event.preventDefault();\n      }\n      this.mousePosition = this.toCanvasPosition(event);\n\n      const isLeft = isTouchEvent(event) || (event instanceof MouseEvent && event.button === 0);\n      const isRight = event instanceof MouseEvent && event.button === 2;\n\n      if (isLeft) {\n        this.listener?.(new ClickEvent(this.mousePosition, false));\n        this.leftClicking = true;\n      } else if (isRight) {\n        this.listener?.(new ClickEvent(this.mousePosition, true));\n        this.rightClicking = true;\n      }\n    });\n\n    this.canvas.addEventListener(IS_MOBILE ? \"touchend\" : \"mouseup\", (event) => {\n      const isLeft = isTouchEvent(event) || (event instanceof MouseEvent && event.button === 0);\n      const isRight = event instanceof MouseEvent && event.button === 2;\n\n      if (isLeft) {\n        this.leftClicking = false;\n      } else if (isRight) {\n        this.rightClicking = false;\n      }\n    });\n\n    this.canvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n\n    // Stop current clicks on mouse leave\n    this.canvas.addEventListener(IS_MOBILE ? \"touchend\" : \"mouseleave\", () => {\n      this.leftClicking = false;\n      this.rightClicking = false;\n    });\n\n    this.canvas.addEventListener(\"wheel\", (event) => {\n      this.listener?.(new ScrollEvent(event.deltaY));\n    });\n\n    const wireButton = (id: string, input: Key | (() => InputEvent)) => {\n      const btn = document.getElementById(id);\n\n      if (!btn) {\n        return;\n      }\n\n      btn.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n\n        if (typeof input === \"function\") {\n          this.listener?.(input());\n        } else {\n          this.isButtonDown[input] = true;\n\n          onKeyEvent(input);\n        }\n      });\n\n      btn.addEventListener(\"touchcancel\", (e) => {\n        e.preventDefault();\n        if (typeof input === \"function\") {\n          // Do nothing\n        } else {\n          this.isButtonDown[input] = false;\n        }\n      });\n\n      btn.addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        if (typeof input === \"function\") {\n          // Do nothing\n        } else {\n          this.isButtonDown[input] = false;\n        }\n      });\n    };\n\n    wireButton(\"left\", Input.Left);\n    wireButton(\"right\", Input.Right);\n    wireButton(\"jump\", Input.Jump);\n    wireButton(\"down\", Input.Down);\n    wireButton(\"map\", Input.Map);\n    wireButton(\"exit\", Input.Escape);\n    wireButton(\"zoom-in\", () => new ScrollEvent(1, true));\n    wireButton(\"zoom-out\", () => new ScrollEvent(-1, true));\n  }\n\n  toCanvasPosition(event: MouseEvent | TouchEvent) {\n    const e = isTouchEvent(event)\n      ? (event.touches.item(0) || { clientX: 0, clientY: 0 })\n      : event;\n    return Vector.scale(\n      new Vector(\n        // Subtract half client width and height to have 0, 0 be in the center of the screen\n        e.clientX - this.canvas.offsetLeft + window.scrollX - this.canvas.clientWidth / 2,\n        e.clientY - this.canvas.offsetTop + window.scrollY - this.canvas.clientHeight / 2\n      ),\n      ((this.canvas.width / this.canvas.clientWidth) * ON_SCREEN_CANVAS_WIDTH) /\n        ON_SCREEN_CANVAS_WIDTH\n    );\n  }\n\n  /**\n   * @return {InputState} The current state of inputs\n   */\n  getInputState() {\n    return new InputState(\n      this.isButtonDown,\n      this.mousePosition,\n      this.leftClicking,\n      this.rightClicking\n    );\n  }\n}\n", "import {\n  CANVAS_HEIGHT,\n  CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_HEIGHT,\n  ON_SCREEN_CANVAS_WIDTH,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nimport { Canvas } from \"./Canvas\";\n\nconst REAL_CANVAS = Symbol(\"real-canvas\");\n\nfunction getRawCanvas(): HTMLCanvasElement {\n  const rawCanvas = document.getElementById(\"canvas\");\n\n  if (!(rawCanvas instanceof HTMLCanvasElement)) {\n    throw new Error(\"Could not find canvas\");\n  }\n\n  rawCanvas.width = ON_SCREEN_CANVAS_WIDTH;\n  rawCanvas.height = ON_SCREEN_CANVAS_HEIGHT;\n\n  return rawCanvas;\n}\n\nexport class ScreenManager {\n  [REAL_CANVAS]: Canvas;\n  // background: Canvas;\n  // behindGroundCanvas: Canvas;\n  staticWorldCanvas: Canvas;\n  dynamicWorldCanvas: Canvas;\n  uiCanvas: Canvas;\n  camera: Vector;\n\n  constructor() {\n    const screenCanvas = new Canvas(getRawCanvas());\n\n    if (!(screenCanvas instanceof Canvas)) {\n      throw Error(\"No canvas found!\");\n    }\n\n    this[REAL_CANVAS] = screenCanvas;\n\n    // this.background = Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 4);\n\n    // this.behindGroundCanvas = Canvas.fromScratch(\n    //   CANVAS_WIDTH * 3,\n    //   CANVAS_HEIGHT * 4\n    // );\n    this.staticWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 4\n    );\n    this.dynamicWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 4\n    );\n    this.uiCanvas = Canvas.fromScratch(\n      ON_SCREEN_CANVAS_WIDTH,\n      ON_SCREEN_CANVAS_HEIGHT\n    );\n\n    // Stores the top-left position of the camera\n    this.camera = new Vector(0, 0);\n  }\n\n  setCamera(cameraPosition: Vector) {\n    this.camera = Vector.diff(cameraPosition, new Vector(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2));\n  }\n\n  drawCanvas(\n    canvas: Canvas,\n    camera: Vector,\n    width = CANVAS_WIDTH,\n    height = CANVAS_HEIGHT\n  ) {\n    this[REAL_CANVAS].drawImage(\n      canvas,\n      camera.x,\n      camera.y,\n      width,\n      height,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height\n    );\n  }\n\n  drawToScreen() {\n    this[REAL_CANVAS].clear();\n    // this.drawCanvas(this.background, this.camera);\n    // this.drawCanvas(this.behindGroundCanvas, this.camera);\n    this.drawCanvas(this.staticWorldCanvas, this.camera);\n    this.drawCanvas(this.dynamicWorldCanvas, this.camera);\n    this.drawCanvas(\n      this.uiCanvas,\n      new Vector(0, 0),\n      CANVAS_WIDTH,\n      CANVAS_HEIGHT,\n    );\n  }\n\n  static instance = null;\n  static getInstance() {\n    if (this.instance) {\n      return this.instance;\n    }\n\n    return new ScreenManager();\n  }\n}\n", "import { GameModeManager } from \"./GameModeManager\";\nimport { InputEvent, InputManager } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\nconst MAX_FRAME_TIME = 1 / 20;\n\nexport class App {\n  gameModeManager: GameModeManager;\n  inputManager: InputManager;\n  screenManager: ScreenManager;\n\n  lastFrameTime = 0;\n\n  constructor() {\n    this.gameModeManager = new GameModeManager();\n    this.inputManager = new InputManager((input) => this.onInput(input));\n    this.screenManager = new ScreenManager();\n\n    this.lastFrameTime = performance.now();\n  }\n\n  start() {\n    this.inputManager.init();\n    requestAnimationFrame(() => this.mainLoop());\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.gameModeManager.onInput(input);\n  }\n\n  mainLoop() {\n    const now = performance.now();\n\n    const deltaTime = Math.min(\n      (now - this.lastFrameTime) / 1000,\n      MAX_FRAME_TIME,\n    );\n\n    this.gameModeManager.update(deltaTime, this.inputManager.getInputState());\n    this.gameModeManager.draw(this.screenManager);\n    this.screenManager.drawToScreen();\n\n    requestAnimationFrame(() => this.mainLoop());\n    this.lastFrameTime = now;\n  }\n}\n\nconst main = () => {\n  const app = new App();\n\n  app.start();\n};\n\nwindow.onload = () => {\n  main();\n};\n"],
  "mappings": "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",
  "names": ["Up", "Down", "Left", "Right", "Jump", "Interact", "Escape", "Map", "Input", "IS_MOBILE", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "clamp", "x", "low", "high", "sign", "floorTo", "fidelity", "ZERO", "toHex", "number", "digits", "rgbaColor", "red", "green", "blue", "alpha", "hslaColor", "hue", "saturation", "lightness", "CTX", "CANVAS", "Canvas", "_Canvas", "canvas", "ctx", "x", "y", "width", "height", "inset", "xRadius", "yRadius", "radius", "cornerCut", "short", "startAngle", "toPoint", "sign", "x0", "y0", "x1", "y1", "xControl", "yControl", "xScale", "yScale", "xOffset", "yOffset", "pattern", "colorString", "red", "green", "blue", "alpha", "rgbaColor", "hue", "saturation", "lightness", "hslaColor", "r0", "r1", "imageSource", "sourceX", "sourceY", "sourceWidth", "sourceHeight", "destinationX", "destinationY", "destinationWidth", "destinationHeight", "image", "id", "Vector", "_Vector", "x", "y", "vector", "factor", "otherVector", "magnitude", "a", "b", "xDiff", "yDiff", "v1", "v2", "t", "ExitEvent", "roomKey", "direction", "Rectangle", "_Rectangle", "x1", "y1", "x2", "y2", "point", "Vector", "x", "y", "otherRectangle", "circle", "closestX", "clamp", "closestY", "p0", "pToCenter", "distFromCenter", "circleDistToMyCenter", "horizontalDistance", "verticalDistance", "sign", "canvas", "outset", "inset", "insetBy", "width", "height", "halfWidth", "halfHeight", "rectangles", "rect", "Octagon", "center", "radius", "cornerCut", "rectangle", "rectMid", "mid", "xDiff", "yDiff", "manhattanIdeal", "xDist", "yDist", "manhattanOverlap", "PLAYER_MAX_SPEED", "PLAYER_ACCEL", "Player", "position", "Octagon", "Vector", "cursor", "floorTo", "input", "room", "Input", "cursorCell", "deltaTime", "inputState", "inputX", "inputY", "acceleration", "totalVel", "off", "block", "canvas", "DOORWAY_SIZE", "BOUNDARY", "randint", "max", "Room", "key", "width", "height", "floorTo", "Rectangle", "Vector", "Player", "i", "j", "deltaTime", "inputState", "mode", "exit", "ExitEvent", "input", "position", "removedIndex", "index", "block", "newRect", "screenManager", "canvas", "insetRect", "insetBy", "event", "map", "parseKey", "s", "x", "y", "Vector", "encodeKey", "v", "directionMap", "RoomWeb", "position", "newRoom", "Room", "event", "roomKey", "direction", "nextPosition", "nextKey", "nextRoom", "DEBUG_SHOW_ALL_ROOMS", "MAX_ZOOM", "MIN_ZOOM", "ZOOM_SPEED", "ZOOM_LEVELS", "ZOOMS_REVERSED", "MAP_PLAYER_SCALE", "MAP_CANVAS_SCALE", "MapMode", "gameModeManager", "Vector", "currentRoom", "room", "canvas", "Canvas", "position", "_deltaTime", "inputState", "currentWorldPos", "found", "icon", "inputEvent", "event", "scroll", "x", "clamp", "y", "parseKey", "screenManager", "currentPlayer", "roomCanvas", "worldPosition", "offset", "PlayMode", "gameModeManager", "RoomWeb", "room", "event", "exit", "deltaTime", "inputState", "input", "screenManager", "ALL_SECTIONS", "GameModeManager", "PlayMode", "MapMode", "deltaTime", "inputState", "mode", "input", "consumed", "Input", "screenManager", "sectionIds", "IS_MOBILE", "section", "KEY_MAP", "Input", "isTouchEvent", "event", "InputState", "_InputState", "keyMap", "mousePosition", "leftClicking", "rightClicking", "input", "Vector", "InputEvent", "_key", "KeyPressEvent", "key", "ClickEvent", "position", "isRightClick", "ScrollEvent", "delta", "discrete", "InputManager", "listener", "onKeyEvent", "symbol", "e", "IS_MOBILE", "isLeft", "isRight", "wireButton", "id", "btn", "ON_SCREEN_CANVAS_WIDTH", "REAL_CANVAS", "getRawCanvas", "rawCanvas", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "ScreenManager", "_ScreenManager", "screenCanvas", "Canvas", "Vector", "cameraPosition", "canvas", "camera", "width", "height", "MAX_FRAME_TIME", "App", "GameModeManager", "InputManager", "input", "ScreenManager", "now", "deltaTime", "main"]
}
