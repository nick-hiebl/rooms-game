{
  "version": 3,
  "sources": ["../src/constants/Keys.ts", "../src/constants/ScreenConstants.ts", "../src/math/Common.ts", "../src/utils/Color.ts", "../src/Canvas.ts", "../src/math/Vector.ts", "../src/game-modes/MapMode.ts", "../src/game-modes/GameEvent.ts", "../src/math/Shapes.ts", "../src/room/Player.ts", "../src/room/Room.ts", "../src/room/RoomWeb.ts", "../src/game-modes/PlayMode.ts", "../src/GameModeManager.ts", "../src/InputManager.ts", "../src/ScreenManager.ts", "../src/App.ts"],
  "sourcesContent": ["const Up = Symbol(\"Up\");\nconst Down = Symbol(\"Down\");\nconst Left = Symbol(\"Left\");\nconst Right = Symbol(\"Right\");\nconst Jump = Symbol(\"Jump\");\nconst Interact = Symbol(\"Interact\");\nconst Escape = Symbol(\"Escape\");\nconst Map = Symbol(\"Map\");\n\n// TODO Convert this to an enum\nexport const Input = {\n  Down,\n  Escape,\n  Interact,\n  Jump,\n  Left,\n  Right,\n  Up,\n  Map,\n};\n", "export const CANVAS_WIDTH = 1280;\nexport const CANVAS_HEIGHT = 720;\n\n// export const HORIZONTAL_TILES = 32;\n// export const VERTICAL_TILES = 18;\n\n// export const PIXELS_PER_TILE = 10;\n\n// export const PIXEL_WIDTH = CANVAS_WIDTH / HORIZONTAL_TILES / PIXELS_PER_TILE;\n\nexport const IS_MOBILE =\n  /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n    navigator.userAgent,\n  );\n\nexport const ON_SCREEN_CANVAS_WIDTH = 1280;\nexport const ON_SCREEN_CANVAS_HEIGHT = 720;\n", "/**\n * Clamps a parameter between a low and high bound.\n * @param {number} x The number to be clamped\n * @param {number} low The lowest value that could be returned\n * @param {number} high The highest value that could be returned\n */\nexport const clamp = (x: number, low: number, high: number): number => {\n  return Math.min(high, Math.max(x, low));\n};\n\nexport const sign = (x: number): number => {\n  if (x > 0) {\n    return 1;\n  } else if (x === 0) {\n    return 0;\n  } else {\n    return -1;\n  }\n};\n\nexport const floorTo = (x: number, fidelity: number): number => {\n  return fidelity * Math.floor(x / fidelity);\n};\n\nexport const randint = (max: number) => Math.floor(Math.random() * max);\n\nexport function shuffle<T>(array: T[]) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const swapTo = randint(i + 1);\n\n    [array[i], array[swapTo]] = [array[swapTo], array[i]];\n  }\n\n  return array;\n}\n", "const HEX = 16;\nconst ZERO = \"0\";\n\n/**\n * A function to convert a number to a zero-padded hex string.\n * @param {number} number The number to be converted\n * @param {number} digits The expected length (for zero-padding purposes)\n */\nexport const toHex = (number: number, digits: number) => {\n  return number.toString(HEX).padStart(digits, ZERO);\n};\n\nexport const rgbaColor = (\n  red: number,\n  green: number,\n  blue: number,\n  alpha = 255,\n) => {\n  return `#${toHex(red, 2)}${toHex(green, 2)}${toHex(blue, 2)}${toHex(\n    alpha,\n    2,\n  )}`;\n};\n\nexport const hslaColor = (\n  hue: number,\n  saturation: number,\n  lightness: number,\n  alpha = 1,\n) => {\n  return `hsla(${hue},${Math.floor(saturation * 100)}%,${Math.floor(\n    lightness * 100,\n  )}%,${alpha})`;\n};\n\nconst rgbToHue = (r: number, g: number, b: number): number => {\n  let h = 0;\n\n  const min = Math.min(r, g, b);\n  const max = Math.max(r, g, b);\n\n  if (max === r) {\n    h = (g - b) / (max - min);\n  }\n  if (max === g) {\n    h = 2 + (b - r) / (max - min);\n  }\n  if (max === b) {\n    h = 4 + (r - g) / (max - min);\n  }\n  if (isNaN(h)) {\n    h = 0;\n  }\n  h = h * 60;\n  if (h < 0) {\n    h = h + 360;\n  }\n  return h;\n};\n\nconst fromHex = (hexColor: string): [number, number, number] => {\n  return [\n    parseInt(hexColor.slice(1, 3), 16),\n    parseInt(hexColor.slice(3, 5), 16),\n    parseInt(hexColor.slice(5, 7), 16),\n  ];\n};\n\nexport const hexToHue = (hexColor: string) => {\n  const [r, g, b] = fromHex(hexColor);\n  return rgbToHue(r, g, b);\n};\n", "import { sign } from \"./math/Common\";\nimport { hslaColor, rgbaColor } from \"./utils/Color\";\n\nconst CTX = Symbol(\"ctx\");\nconst CANVAS = Symbol(\"canvas\");\n\nexport class Canvas {\n  [CANVAS]: HTMLCanvasElement;\n  [CTX]: CanvasRenderingContext2D;\n  width: number;\n  height: number;\n\n  constructor(canvas: HTMLCanvasElement) {\n    this[CANVAS] = canvas;\n    const ctx = canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      throw Error(\"Unable to get 2d context\");\n    }\n\n    ctx.imageSmoothingEnabled = false;\n\n    this[CTX] = ctx;\n\n    this[CTX].fillStyle = \"black\";\n    this[CTX].strokeStyle = \"black\";\n\n    this.width = this[CANVAS].width;\n    this.height = this[CANVAS].height;\n  }\n\n  /**\n   * Fill a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  fillRect(x: number, y: number, width: number, height: number) {\n    this[CTX].fillRect(x, y, width, height);\n  }\n\n  clear() {\n    this[CTX].clearRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Draw the outline of a rectangle on the canvas.\n   * @param {number} x The horizontal position of the top-left corner.\n   * @param {number} y The vertical position of the top-left corner.\n   * @param {number} width The width of the rectangle.\n   * @param {number} height The height of the rectangle.\n   */\n  strokeRect(x: number, y: number, width: number, height: number) {\n    this[CTX].strokeRect(x, y, width, height);\n  }\n\n  strokeRectInset(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    inset: number,\n  ) {\n    this.strokeRect(\n      x + inset,\n      y + inset,\n      width - inset * 2,\n      height - inset * 2,\n    );\n  }\n\n  /**\n   * Fill an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  fillEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].fill();\n  }\n\n  fillTriangle(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y + height);\n    this[CTX].lineTo(x + width, y + height);\n    this[CTX].lineTo(x + width / 2, y);\n    this[CTX].fill();\n  }\n\n  /**\n   * Outline an ellipse on the canvas.\n   * @param {number} x The horizontal position of the ellipse center.\n   * @param {number} y The vertical position of the ellipse center.\n   * @param {number} width The horizontal radius of the ellipse.\n   * @param {number} height The vertical radius of the ellipse.\n   */\n  strokeEllipse(x: number, y: number, width: number, height: number) {\n    this[CTX].beginPath();\n    this[CTX].ellipse(x, y, width, height, 0, 0, 2 * Math.PI);\n    this[CTX].stroke();\n  }\n\n  fillDiamond(x: number, y: number, xRadius: number, yRadius: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x, y - yRadius);\n    this[CTX].lineTo(x + xRadius, y);\n    this[CTX].lineTo(x, y + yRadius);\n    this[CTX].lineTo(x - xRadius, y);\n    this[CTX].lineTo(x, y - yRadius);\n    this[CTX].fill();\n  }\n\n  fillOctagon(x: number, y: number, radius: number, cornerCut: number) {\n    const short = radius - cornerCut;\n    this[CTX].beginPath();\n    this[CTX].moveTo(x - short, y - radius);\n    this[CTX].lineTo(x + short, y - radius);\n    this[CTX].lineTo(x + radius, y - short);\n    this[CTX].lineTo(x + radius, y + short);\n    this[CTX].lineTo(x + short, y + radius);\n    this[CTX].lineTo(x - short, y + radius);\n    this[CTX].lineTo(x - radius, y + short);\n    this[CTX].lineTo(x - radius, y - short);\n    this[CTX].lineTo(x - short, y - radius);\n    this[CTX].fill();\n  }\n\n  outerCircleCorner(x: number, y: number, radius: number, startAngle: number) {\n    this[CTX].beginPath();\n    this[CTX].arc(x, y, radius, startAngle, startAngle + Math.PI / 2);\n    const toPoint = startAngle + Math.PI / 4;\n    this[CTX].lineTo(\n      x + sign(Math.cos(toPoint)) * radius,\n      y + sign(Math.sin(toPoint)) * radius,\n    );\n    this[CTX].fill();\n  }\n\n  /**\n   * Draw a line on the canvas.\n   * @param {number} x0 The start x position\n   * @param {number} y0 The start y position\n   * @param {number} x1 The end x position\n   * @param {number} y1 The start y position\n   */\n  drawLine(x0: number, y0: number, x1: number, y1: number) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].lineTo(x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Draw a quadratic bezier curve on the canvas.\n   * @param {*} x0 The starting x position\n   * @param {*} y0 The starting y position\n   * @param {*} x1 The ending x position\n   * @param {*} y1 The ending y position\n   * @param {*} xControl The control point x position\n   * @param {*} yControl The control point y position\n   */\n  drawQuadratic(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    xControl: number,\n    yControl: number,\n  ) {\n    this[CTX].beginPath();\n    this[CTX].moveTo(x0, y0);\n    this[CTX].quadraticCurveTo(xControl, yControl, x1, y1);\n    this[CTX].stroke();\n  }\n\n  /**\n   * Scale the canvas.\n   * @param {number} xScale\n   * @param {number} yScale\n   */\n  scale(xScale: number, yScale: number) {\n    this[CTX].scale(xScale, yScale);\n  }\n\n  /**\n   * Translate the canvas.\n   * @param {number} xOffset\n   * @param {number} yOffset\n   */\n  translate(xOffset: number, yOffset: number) {\n    this[CTX].translate(xOffset, yOffset);\n  }\n\n  translateCenterTo(xOffset: number, yOffset: number) {\n    this[CTX].translate(-xOffset + this.width / 2, -yOffset + this.height / 2);\n  }\n\n  setLineWidth(width: number) {\n    this[CTX].lineWidth = width;\n  }\n\n  get lineWidth() {\n    return this[CTX].lineWidth;\n  }\n\n  setLineDash(pattern: number[]) {\n    this[CTX].setLineDash(pattern);\n  }\n\n  /**\n   * Set the colour to be used for drawing on the canvas.\n   * @param {string} colorString The name of the color to be used\n   */\n  setColor(colorString: CanvasRenderingContext2D[\"fillStyle\"]) {\n    if (colorString === this[CTX].fillStyle) {\n      return;\n    }\n\n    this[CTX].fillStyle = colorString;\n    this[CTX].strokeStyle = colorString;\n  }\n\n  /**\n   * Set the current color via RGB.\n   * @param {number} red Red value from 0-255\n   * @param {number} green Green value from 0-255\n   * @param {number} blue Blue value from 0-255\n   * @param {number | undefined} alpha Alpha value from 0-255\n   */\n  setColorRGB(red: number, green: number, blue: number, alpha = 255) {\n    this.setColor(rgbaColor(red, green, blue, alpha));\n  }\n\n  /**\n   * Set the current color with hue, saturation, lightness and alpha.\n   * @param {number} hue Hue value from 0-359\n   * @param {number} saturation Saturation value from 0-1\n   * @param {number} lightness Lightness value from 0-1\n   * @param {number | undefined} alpha Alpha value from 0-1\n   */\n  setColorHSLA(hue: number, saturation: number, lightness: number, alpha = 1) {\n    this.setColor(hslaColor(hue, saturation, lightness, alpha));\n  }\n\n  createGradient(x0: number, y0: number, x1: number, y1: number) {\n    return this[CTX].createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(\n    x0: number,\n    y0: number,\n    r0: number,\n    x1: number,\n    y1: number,\n    r1: number,\n  ) {\n    return this[CTX].createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  saveTransform() {\n    this[CTX].save();\n  }\n\n  restoreTransform() {\n    this[CTX].restore();\n  }\n\n  /**\n   * Draw another image to this canvas\n   * @param {Canvas} imageSource\n   * @param {number} sourceX\n   * @param {number} sourceY\n   * @param {number} sourceWidth\n   * @param {number} sourceHeight\n   * @param {number} destinationX\n   * @param {number} destinationY\n   * @param {number} destinationWidth\n   * @param {nubmer} destinationHeight\n   */\n  drawImage(\n    imageSource: Canvas | HTMLImageElement,\n    sourceX: number,\n    sourceY: number,\n    sourceWidth: number,\n    sourceHeight: number,\n    destinationX: number,\n    destinationY: number,\n    destinationWidth: number,\n    destinationHeight: number,\n  ) {\n    let image: CanvasImageSource;\n    if (imageSource instanceof Canvas) {\n      image = imageSource[CANVAS];\n    } else if (imageSource instanceof Image) {\n      if (!imageSource.complete) {\n        return;\n      }\n      image = imageSource;\n    } else {\n      throw Error(\"Drawing something unmanageable\");\n    }\n\n    this[CTX].drawImage(\n      image,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      destinationX,\n      destinationY,\n      destinationWidth,\n      destinationHeight,\n    );\n  }\n\n  /**\n   * Create a Canvas from an id.\n   * @param {string} id The id attribute of the HTMLCanvasElement\n   */\n  static fromId(id: string) {\n    const canvas = document.getElementById(id);\n\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n      throw new Error(`Could not find canvas with id: \"${id}\"`);\n    }\n\n    return new Canvas(canvas);\n  }\n\n  /**\n   * Create a new HTMLCanvasElement and use that as the basis for a Canvas.\n   */\n  static fromScratch(width: number, height: number) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n\n    return new Canvas(canvas);\n  }\n}\n", "export class Vector {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(vector: Vector) {\n    this.x += vector.x;\n    this.y += vector.y;\n\n    return this;\n  }\n\n  subtract(vector: Vector) {\n    this.x -= vector.x;\n    this.y -= vector.y;\n  }\n\n  multiply(factor: number) {\n    this.x *= factor;\n    this.y *= factor;\n\n    return this;\n  }\n\n  copy() {\n    return new Vector(this.x, this.y);\n  }\n\n  setFrom(otherVector: Vector) {\n    this.x = otherVector.x;\n    this.y = otherVector.y;\n  }\n\n  get magnitude(): number {\n    return Math.hypot(this.x, this.y);\n  }\n\n  setMagnitude(magnitude: number) {\n    if (this.x === 0 && this.y == 0) {\n      return;\n    }\n\n    this.multiply(magnitude / this.magnitude);\n  }\n\n  static add(a: Vector, b: Vector) {\n    return new Vector(a.x + b.x, a.y + b.y);\n  }\n\n  static diff(a: Vector, b: Vector) {\n    return new Vector(a.x - b.x, a.y - b.y);\n  }\n\n  static scale(vector: Vector, factor: number) {\n    return new Vector(vector.x * factor, vector.y * factor);\n  }\n\n  static sqrDist(a: Vector, b: Vector): number {\n    const xDiff = a.x - b.x;\n    const yDiff = a.y - b.y;\n    return xDiff * xDiff + yDiff * yDiff;\n  }\n\n  /**\n   * This is not actually manhattan distance. Consider refactoring.\n   */\n  static manhattanDist(a: Vector, b: Vector) {\n    return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));\n  }\n\n  static dist(a: Vector, b: Vector) {\n    return Math.hypot(a.x - b.x, a.y - b.y);\n  }\n\n  static lerp(v1: Vector, v2: Vector, t: number) {\n    return new Vector(v1.x * (1 - t) + v2.x * t, v1.y * (1 - t) + v2.y * t);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { GameModeManager } from \"../GameModeManager\";\nimport {\n  ClickEvent,\n  InputEvent,\n  InputState,\n  ScrollEvent,\n} from \"../InputManager\";\nimport { Room } from \"../room/Room\";\nimport { clamp, floorTo } from \"../math/Common\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { PlayMode } from \"./PlayMode\";\nimport { parseKey, RoomWeb } from \"../room/RoomWeb\";\nimport {\n  GRID_SIZE,\n  WORLD_GRID_HEIGHT,\n  WORLD_GRID_WIDTH,\n} from \"../constants/WorldConstants\";\n\nconst DEBUG_SHOW_ALL_ROOMS = document.location.toString().includes(\"localhost\");\n\nconst MAX_ZOOM = 0.5;\nconst MIN_ZOOM = 0.05;\nconst ZOOM_SPEED = 0.001;\n\nconst ZOOM_LEVELS = [0.05, 0.1, 0.15, 0.2, 0.3, 0.5];\nconst ZOOMS_REVERSED = ZOOM_LEVELS.slice();\nZOOMS_REVERSED.reverse();\n\nconst MAP_PLAYER_SCALE = 60;\n\nconst MAP_CANVAS_SCALE = 10;\n\ninterface MapInteractible {\n  room: Room;\n  interactible: unknown;\n  isHovered: boolean;\n  position: Vector;\n}\n\nexport class MapMode {\n  gameModeManager: GameModeManager;\n  playMode: PlayMode;\n  cameraPosition: Vector;\n  zoom: number;\n\n  mousePosition: Vector;\n  isClicked: boolean;\n  hoverPosition: Vector;\n\n  canvasW: number;\n  canvasH: number;\n\n  roomCanvasMap: Map<string, Canvas>;\n  drawIcons: MapInteractible[];\n\n  constructor(gameModeManager: GameModeManager) {\n    this.gameModeManager = gameModeManager;\n    this.playMode = gameModeManager.playMode;\n    this.cameraPosition = new Vector(0, 0);\n    this.setCameraPos();\n    this.zoom = MAX_ZOOM;\n\n    this.mousePosition = new Vector(0, 0);\n    this.isClicked = false;\n    this.hoverPosition = new Vector(0, 0);\n\n    this.canvasW = 0;\n    this.canvasH = 0;\n\n    this.roomCanvasMap = new Map<string, Canvas>();\n    this.drawIcons = [];\n  }\n\n  setCameraPos() {\n    const currentRoom = this.playMode.roomWeb.currentRoom;\n    this.cameraPosition = Vector.add(\n      this.getRoomPosition(currentRoom),\n      new Vector(currentRoom.width / 2, currentRoom.height / 2),\n    );\n  }\n\n  onStart() {\n    this.setCameraPos();\n    this.mousePosition = new Vector(0, 0);\n    this.isClicked = false;\n    this.hoverPosition = new Vector(0, 0);\n\n    this.predrawRooms();\n    this.drawIcons = this.getIconsToShow();\n  }\n\n  getIconsToShow(): MapInteractible[] {\n    const icons: MapInteractible[] = [];\n    // for (const room of this.playMode.roomWeb.rooms) {\n    //   for (const entity of room.entities) {\n    //     if (interactible.showAsMapIcon) {\n    //       icons.push({\n    //         room,\n    //         entity,\n    //         position: Vector.add(level.worldPosition, interactible.position),\n    //         isHovered: false,\n    //       });\n    //     }\n    //   }\n    // }\n\n    return icons;\n  }\n\n  predrawRooms() {\n    for (const room of this.playMode.roomWeb.rooms) {\n      if (!DEBUG_SHOW_ALL_ROOMS && !room.visited) {\n        continue;\n      }\n\n      const canvas =\n        this.roomCanvasMap.get(room.key) ||\n        Canvas.fromScratch(\n          ((room.width * 1) / GRID_SIZE) * MAP_CANVAS_SCALE,\n          ((room.height * 1) / GRID_SIZE) * MAP_CANVAS_SCALE,\n        );\n\n      // canvas.saveTransform();\n      // canvas.scale(, );\n      room.drawForMap(canvas);\n      // canvas.restoreTransform();\n\n      this.roomCanvasMap.set(room.key, canvas);\n    }\n  }\n\n  toWorldPosition(position: Vector) {\n    return Vector.add(\n      Vector.scale(position, 1 / this.zoom),\n      this.cameraPosition,\n    );\n  }\n\n  update(_deltaTime: number, inputState: InputState) {\n    const currentWorldPos = this.toWorldPosition(inputState.mousePosition);\n\n    this.hoverPosition = this.toWorldPosition(inputState.mousePosition);\n\n    let found: MapInteractible | undefined = undefined;\n    for (const icon of this.drawIcons) {\n      // Only allow one icon to be hovered\n      if (found) {\n        icon.isHovered = false;\n        continue;\n      }\n\n      if (Vector.sqrDist(icon.position, currentWorldPos) < 32) {\n        icon.isHovered = true;\n        found = icon;\n      } else {\n        icon.isHovered = false;\n      }\n    }\n\n    if (inputState.isLeftClicking() && this.isClicked) {\n      this.cameraPosition.subtract(\n        Vector.diff(currentWorldPos, this.mousePosition),\n      );\n    } else {\n      this.isClicked = false;\n    }\n  }\n\n  onInput(inputEvent: InputEvent) {\n    // Do nothing\n    if (inputEvent.isClick()) {\n      const event = inputEvent as ClickEvent;\n\n      if (!event.isRightClick()) {\n        this.mousePosition = this.toWorldPosition(event.position);\n        this.isClicked = true;\n\n        const mousePosition = this.toWorldPosition(event.position);\n\n        const room = this.positionToRoomIndex(mousePosition);\n\n        if (!this.playMode.roomWeb.getRoom(room)) {\n          const newRoom = this.playMode.roomWeb.createRoom(room, 2, 2);\n\n          if (newRoom && !this.roomCanvasMap.get(newRoom.key)) {\n            this.predrawRooms();\n          }\n        }\n      }\n      // const hoveredIcon = this.drawIcons.find((icon) => icon.isHovered);\n\n      // const isAPortalActive = this.playMode.currentLevel.interactingWith instanceof PortalInteractible;\n\n      // if (hoveredIcon && isAPortalActive) {\n      //   const event = hoveredIcon.interactible.clickedOnMap();\n\n      //   if (event) {\n      //     event.process(this.playMode);\n      //     this.gameModeManager.switchToMode(this.playMode);\n      //   }\n      // }\n    } else if (inputEvent.isScroll()) {\n      const scroll = inputEvent as ScrollEvent;\n      if (scroll.discrete) {\n        if (scroll.delta > 0) {\n          this.zoom = ZOOM_LEVELS.find((x) => x > this.zoom) || MAX_ZOOM;\n        } else {\n          this.zoom = ZOOMS_REVERSED.find((x) => x < this.zoom) || MIN_ZOOM;\n        }\n      } else {\n        this.zoom = clamp(\n          this.zoom + scroll.delta * -ZOOM_SPEED,\n          MIN_ZOOM,\n          MAX_ZOOM,\n        );\n      }\n    }\n  }\n\n  getRoomPosition(room: Room) {\n    const { x, y } = room.position;\n\n    return new Vector(x * WORLD_GRID_WIDTH, y * WORLD_GRID_HEIGHT);\n  }\n\n  positionToRoomIndex(position: Vector) {\n    const hoveredRoomPosition = new Vector(\n      floorTo(position.x, WORLD_GRID_WIDTH),\n      floorTo(position.y, WORLD_GRID_HEIGHT),\n    );\n\n    return new Vector(\n      hoveredRoomPosition.x / WORLD_GRID_WIDTH,\n      hoveredRoomPosition.y / WORLD_GRID_HEIGHT,\n    );\n  }\n\n  draw(screenManager: ScreenManager) {\n    const currentRoom = this.playMode.roomWeb.currentRoom;\n\n    const canvas = screenManager.uiCanvas;\n    this.canvasW = canvas.width;\n    this.canvasH = canvas.height;\n\n    canvas.setColor(\"black\");\n    canvas.fillRect(0, 0, canvas.width, canvas.height);\n\n    canvas.saveTransform();\n    canvas.translate(canvas.width / 2, canvas.height / 2);\n\n    canvas.scale(this.zoom, this.zoom);\n\n    canvas.translate(-this.cameraPosition.x, -this.cameraPosition.y);\n\n    const currentPlayer = currentRoom.player;\n\n    for (const room of this.playMode.roomWeb.rooms) {\n      const roomCanvas = this.roomCanvasMap.get(room.key);\n      if ((!DEBUG_SHOW_ALL_ROOMS && !room.visited) || !roomCanvas) {\n        continue;\n      }\n\n      const position = this.getRoomPosition(room);\n\n      // const hoverPositionInRoom = Vector.diff(this.hoverPosition, position);\n\n      // const isHovered = hoverPositionInRoom.x >= 0 && hoverPositionInRoom.x < room.width &&\n      //   hoverPositionInRoom.y >= 0 && hoverPositionInRoom.y < room.height;\n\n      canvas.drawImage(\n        roomCanvas,\n        0,\n        0,\n        roomCanvas.width,\n        roomCanvas.height,\n        position.x,\n        position.y,\n        room.width,\n        room.height,\n      );\n    }\n\n    const hoveredRoom = new Vector(\n      floorTo(this.hoverPosition.x, WORLD_GRID_WIDTH),\n      floorTo(this.hoverPosition.y, WORLD_GRID_HEIGHT),\n    );\n\n    canvas.setColor(\"#fff6\");\n    canvas.setLineWidth(4);\n    canvas.strokeRect(\n      hoveredRoom.x,\n      hoveredRoom.y,\n      WORLD_GRID_WIDTH,\n      WORLD_GRID_HEIGHT,\n    );\n\n    if (currentPlayer) {\n      const worldPosition = this.getRoomPosition(currentRoom);\n      const offset = Vector.add(\n        worldPosition,\n        new Vector(currentRoom.width / 2, currentRoom.height / 2),\n      );\n      canvas.translate(offset.x, offset.y);\n\n      canvas.setLineWidth(8);\n      canvas.setLineDash([]);\n\n      canvas.setColor(\"white\");\n      canvas.fillEllipse(0, 0, MAP_PLAYER_SCALE, MAP_PLAYER_SCALE);\n      canvas.setColor(\"black\");\n      canvas.strokeEllipse(0, 0, MAP_PLAYER_SCALE, MAP_PLAYER_SCALE);\n\n      canvas.translate(-offset.x, -offset.y);\n    }\n\n    canvas.setColor(\"pink\");\n    canvas.fillEllipse(this.hoverPosition.x, this.hoverPosition.y, 5, 5);\n\n    // const zoom = this.zoom / 2;\n\n    // for (const { room, interactible, isHovered } of this.drawIcons) {\n    //   const worldPosition = this.getRoomPosition(room);\n    //   const offset = Vector.add(worldPosition, interactible.position);\n    //   canvas.translate(offset.x, offset.y);\n    //   const innerZoom = isHovered ? zoom * 0.8 : zoom;\n    //   canvas.scale(1 / innerZoom, 1 / innerZoom);\n\n    //   interactible.drawAsMapIcon(canvas, room);\n\n    //   canvas.scale(innerZoom, innerZoom);\n    //   canvas.translate(-offset.x, -offset.y);\n    // }\n\n    canvas.restoreTransform();\n  }\n}\n", "import { Vector } from \"../math/Vector\";\n\nexport interface GameEvent {\n  isExitEvent(): boolean;\n  isOpenMapEvent(): boolean;\n}\n\nexport type Direction = \"up\" | \"left\" | \"down\" | \"right\";\n\nexport class ExitEvent implements GameEvent {\n  fromKey: Vector;\n  toKey: Vector;\n  direction: Direction;\n\n  constructor(fromKey: Vector, toKey: Vector, direction: Direction) {\n    this.fromKey = fromKey;\n    this.toKey = toKey;\n    this.direction = direction;\n  }\n\n  isExitEvent(): boolean {\n    return true;\n  }\n\n  isOpenMapEvent(): boolean {\n    return false;\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { clamp, sign } from \"./Common\";\nimport { Vector } from \"./Vector\";\n\nexport class Circle {\n  position: Vector;\n  radius: number;\n\n  constructor(position: Vector, radius: number) {\n    this.position = position;\n    this.radius = radius;\n  }\n\n  /**\n   * Check if another circle intersects with this circle\n   * @param {Circle} otherCircle The circle to check intersection with\n   */\n  intersectsCircle(otherCircle: Circle) {\n    const radiusSum = this.radius + otherCircle.radius;\n    return (\n      Vector.sqrDist(this.position, otherCircle.position) <\n      radiusSum * radiusSum\n    );\n  }\n\n  /**\n   * Check if a point intersects with this circle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsVector(point: Vector) {\n    return Vector.sqrDist(this.position, point) < this.radius * this.radius;\n  }\n\n  /**\n   * Check if a rectangle intersects with this circle.\n   * @param {Rectangle} rectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(rectangle: Rectangle) {\n    // Find the co-ordinates of the closest point in the rectangle to the circle center.\n    const closestX = clamp(this.position.x, rectangle.x1, rectangle.x2);\n    const closestY = clamp(this.position.y, rectangle.y1, rectangle.y2);\n\n    // Find if the closest point in the rectangle overlaps with the circle.\n    return this.intersectsVector(new Vector(closestX, closestY));\n  }\n\n  /**\n   * Draw this circle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas) {\n    canvas.fillEllipse(\n      this.position.x,\n      this.position.y,\n      this.radius,\n      this.radius,\n    );\n  }\n}\n\nexport class Rectangle {\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n\n  constructor(x1: number, y1: number, x2: number, y2: number) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  /**\n   * Check if a point intersects with this rectangle.\n   * @param {Vector} point The point to check intersection with\n   */\n  intersectsPoint(point: Vector) {\n    return (\n      this.x1 <= point.x &&\n      point.x <= this.x2 &&\n      this.y1 <= point.y &&\n      point.y <= this.y2\n    );\n  }\n\n  get width() {\n    return this.x2 - this.x1;\n  }\n\n  get height() {\n    return this.y2 - this.y1;\n  }\n\n  get midpoint() {\n    return new Vector((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);\n  }\n\n  xInRange(x: number): boolean {\n    return this.x1 <= x && x < this.x2;\n  }\n\n  yInRange(y: number): boolean {\n    return this.y1 <= y && y < this.y2;\n  }\n\n  /**\n   * Check if another rectangle intersects with this rectangle.\n   * @param {Rectangle} otherRectangle The rectangle to check intersection with\n   */\n  intersectsRectangle(otherRectangle: Rectangle) {\n    return (\n      otherRectangle.x1 <= this.x2 &&\n      this.x1 <= otherRectangle.x2 &&\n      otherRectangle.y1 <= this.y2 &&\n      this.y1 <= otherRectangle.y2\n    );\n  }\n\n  /**\n   * Compute the smallest vector in the reverse direction to movement to\n   * uncollide with a given rectangle.\n   * @param {Circle} circle\n   */\n  uncollideCircle(circle: Circle) {\n    const closestX = clamp(circle.position.x, this.x1, this.x2);\n    const closestY = clamp(circle.position.y, this.y1, this.y2);\n\n    const p0 = new Vector(closestX, closestY);\n    const pToCenter = Vector.diff(circle.position, p0);\n\n    const distFromCenter = pToCenter.magnitude || 1;\n\n    if (distFromCenter >= circle.radius) {\n      const circleDistToMyCenter = Vector.diff(circle.position, this.midpoint);\n      const horizontalDistance =\n        this.width / 2 - Math.abs(circleDistToMyCenter.x);\n      const verticalDistance =\n        this.height / 2 - Math.abs(circleDistToMyCenter.y);\n\n      // Shortest way out is horizontally\n      if (horizontalDistance < verticalDistance) {\n        return new Vector(\n          (horizontalDistance + circle.radius) * sign(circleDistToMyCenter.x),\n          0,\n        );\n      } else {\n        return new Vector(\n          0,\n          (verticalDistance + circle.radius) * sign(circleDistToMyCenter.y),\n        );\n      }\n    }\n\n    return Vector.scale(\n      pToCenter,\n      (circle.radius - distFromCenter) / distFromCenter,\n    );\n  }\n\n  /**\n   * Draw this rectangle onto a canvas.\n   * @param {Canvas} canvas The canvas to draw on.\n   */\n  draw(canvas: Canvas, outset = 0) {\n    canvas.fillRect(\n      this.x1 - outset,\n      this.y1 - outset,\n      this.width + outset * 2,\n      this.height + outset * 2,\n    );\n  }\n\n  stroke(canvas: Canvas, inset = 0) {\n    canvas.strokeRectInset(this.x1, this.y1, this.width, this.height, inset);\n  }\n\n  inset(insetBy: number) {\n    return new Rectangle(\n      this.x1 + insetBy,\n      this.y1 + insetBy,\n      this.x2 - insetBy,\n      this.y2 - insetBy,\n    );\n  }\n\n  static widthForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x, y, x + width, y + height);\n  }\n\n  static centerForm(x: number, y: number, width: number, height: number) {\n    return new Rectangle(x - width, y - height, x + width, y + height);\n  }\n\n  static aroundPoint(point: Vector, halfWidth: number, halfHeight: number) {\n    return new Rectangle(\n      point.x - halfWidth,\n      point.y - halfHeight,\n      point.x + halfWidth,\n      point.y + halfHeight,\n    );\n  }\n\n  // Creates a rectangle that overlaps all of the provided ones\n  static merged(rectangles: Rectangle[]) {\n    const [x1, y1, x2, y2] = rectangles.reduce<\n      [number, number, number, number]\n    >(\n      ([x1, y1, x2, y2], rect) => [\n        Math.min(rect.x1, x1),\n        Math.min(rect.y1, y1),\n        Math.max(rect.x2, x2),\n        Math.max(rect.y2, y2),\n      ],\n      [Infinity, Infinity, -Infinity, -Infinity],\n    );\n\n    return new Rectangle(x1, y1, x2, y2);\n  }\n}\n\nexport class Octagon {\n  center: Vector;\n  radius: number;\n  cornerCut: number;\n\n  constructor(center: Vector, radius: number, cornerCut: number) {\n    this.center = center;\n    this.radius = radius;\n    this.cornerCut = cornerCut;\n  }\n\n  draw(canvas: Canvas) {\n    canvas.fillOctagon(\n      this.center.x,\n      this.center.y,\n      this.radius,\n      this.cornerCut,\n    );\n  }\n\n  intersectsRectangle(rectangle: Rectangle) {\n    const approximate = Rectangle.centerForm(\n      this.center.x,\n      this.center.y,\n      this.radius,\n      this.radius,\n    );\n\n    if (!approximate.intersectsRectangle(rectangle)) {\n      return false;\n    }\n\n    const rectMid = rectangle.midpoint;\n\n    const centerManhattanDistance =\n      Math.abs(rectMid.x - this.center.x) + Math.abs(rectMid.y - this.center.y);\n\n    return (\n      centerManhattanDistance <\n      (rectangle.width + rectangle.height) / 2 +\n        this.radius * 2 -\n        this.cornerCut\n    );\n  }\n\n  intersectsBy(rectangle: Rectangle) {\n    const mid = rectangle.midpoint;\n    const xDiff = Math.abs(this.center.x - mid.x);\n    const yDiff = Math.abs(this.center.y - mid.y);\n\n    return Math.max(\n      0,\n      Math.min(\n        this.radius + rectangle.width / 2 - xDiff,\n        this.radius + rectangle.height / 2 - yDiff,\n      ),\n    );\n  }\n\n  collideRectangle(rectangle: Rectangle) {\n    const rectMid = rectangle.midpoint;\n\n    const xDiff = Math.abs(this.center.x - rectMid.x);\n    const yDiff = Math.abs(this.center.y - rectMid.y);\n\n    if (\n      xDiff >= this.radius + rectangle.width / 2 ||\n      yDiff >= this.radius + rectangle.height / 2\n    ) {\n      // Definitely no overlap\n      return;\n    }\n\n    const manhattanIdeal =\n      (rectangle.width + rectangle.height) / 2 +\n      this.radius * 2 -\n      this.cornerCut;\n\n    if (xDiff + yDiff >= manhattanIdeal) {\n      // In corners, no overlap\n      return;\n    }\n\n    if (!this.intersectsRectangle(rectangle)) {\n      console.error(\"Collision fuck up\");\n    }\n\n    const xDist = rectangle.width / 2 + this.radius;\n    const nextX = rectMid.x + xDist * sign(this.center.x - rectMid.x);\n    const xShove = Math.abs(this.center.x - nextX);\n\n    const yDist = rectangle.height / 2 + this.radius;\n    const nextY = rectMid.y + yDist * sign(this.center.y - rectMid.y);\n    const yShove = Math.abs(this.center.y - nextY);\n\n    if (\n      // Hitting vertical face (sides, not corner)\n      yDiff < this.radius - this.cornerCut + rectangle.height / 2 ||\n      // Hitting horizontal face (top/bottom, not corner)\n      xDiff < this.radius - this.cornerCut + rectangle.width / 2\n    ) {\n      if (xShove < yShove) {\n        this.center.x = nextX;\n      } else {\n        this.center.y = nextY;\n      }\n      return;\n    }\n\n    // Diagonal collision\n    const manhattanOverlap = manhattanIdeal - (xDiff + yDiff);\n\n    this.center.x += (manhattanOverlap / 2) * sign(this.center.x - rectMid.x);\n    this.center.y += (manhattanOverlap / 2) * sign(this.center.y - rectMid.y);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport { Input } from \"../constants/Keys\";\nimport {\n  GRID_SIZE,\n  PLAYER_CORNER,\n  PLAYER_REACH,\n  PLAYER_SIZE,\n} from \"../constants/WorldConstants\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { floorTo } from \"../math/Common\";\nimport { Octagon } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { Room } from \"./Room\";\n\nconst PLAYER_MAX_SPEED = 500;\nconst PLAYER_ACCEL = PLAYER_MAX_SPEED / 1.2;\n\nexport class Player {\n  velocity: Vector;\n  collider: Octagon;\n  direction: Vector | null;\n\n  constructor(position: Vector) {\n    this.collider = new Octagon(position, PLAYER_SIZE, PLAYER_CORNER);\n\n    this.velocity = new Vector(0, 0);\n    this.direction = new Vector(0, -1);\n  }\n\n  getCursorCell() {\n    const cursor = this.direction;\n\n    if (!cursor) {\n      return null;\n    }\n\n    return new Vector(\n      floorTo(cursor.x, GRID_SIZE),\n      floorTo(cursor.y, GRID_SIZE),\n    );\n  }\n\n  onInput(input: InputEvent, room: Room) {\n    if (input.isForKey(Input.Interact) || input.isClick()) {\n      const cursorCell = this.getCursorCell();\n      if (cursorCell) {\n        room.interactOnCell(cursorCell);\n      }\n    }\n  }\n\n  update(deltaTime: number, inputState: InputState, room: Room) {\n    const inputX = inputState.getHorizontalAxis();\n    const inputY = inputState.getVerticalAxis();\n    let acceleration = new Vector(inputX, inputY).multiply(PLAYER_ACCEL);\n\n    this.velocity.add(acceleration.multiply(1));\n    const totalVel = this.velocity.magnitude;\n\n    // this.direction = this.velocity.copy();\n    // this.direction.setMagnitude(GRID_SIZE * 1.0);\n\n    if (totalVel > PLAYER_MAX_SPEED) {\n      this.velocity.multiply(PLAYER_MAX_SPEED / totalVel);\n    }\n\n    if (acceleration.x === 0 && acceleration.y === 0) {\n      this.velocity.multiply(0.5);\n    }\n\n    const off = this.velocity.copy().multiply(deltaTime);\n\n    this.collider.center.add(off);\n\n    for (const block of room.blocks) {\n      this.collider.collideRectangle(block);\n    }\n\n    // this.direction.add(this.collider.center);\n\n    this.direction = Vector.add(inputState.mousePosition, room.camera);\n\n    if (Vector.dist(this.direction, this.collider.center) > PLAYER_REACH) {\n      this.direction = null;\n    }\n  }\n\n  collideWithBlock() {}\n\n  draw(canvas: Canvas) {\n    const cursorCell = this.getCursorCell();\n\n    if (cursorCell) {\n      canvas.setColor(\"#0005\");\n      canvas.setLineWidth(2);\n\n      canvas.strokeRect(cursorCell.x, cursorCell.y, GRID_SIZE, GRID_SIZE);\n    }\n\n    canvas.setColor(\"green\");\n    this.collider.draw(canvas);\n  }\n}\n", "import { Canvas } from \"../Canvas\";\nimport {\n  GRID_SIZE,\n  WORLD_GRID_HEIGHT,\n  WORLD_GRID_WIDTH,\n} from \"../constants/WorldConstants\";\nimport { ExitEvent } from \"../game-modes/GameEvent\";\nimport { PlayMode } from \"../game-modes/PlayMode\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { clamp, floorTo, randint } from \"../math/Common\";\nimport { Rectangle } from \"../math/Shapes\";\nimport { Vector } from \"../math/Vector\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { Player } from \"./Player\";\nimport { encodeKey } from \"./RoomWeb\";\n\nconst DOORWAY_SIZE = GRID_SIZE * 2;\n\nconst BOUNDARY = 50;\n\nexport class Room {\n  key: string;\n  width: number;\n  height: number;\n  collider: Rectangle;\n\n  position: Vector;\n\n  player: Player;\n  camera: Vector;\n\n  visited = false;\n  backgroundDirty = true;\n\n  blocks: Rectangle[];\n  exits: [Rectangle, ExitEvent][];\n\n  color: string;\n\n  constructor(position: Vector, width: number, height: number) {\n    this.color = `hsl(${randint(360)}, ${randint(20) + 50}%, ${\n      randint(30) + 60\n    }%)`;\n\n    this.key = encodeKey(position);\n    this.width = floorTo(width, WORLD_GRID_WIDTH);\n    this.height = floorTo(height, WORLD_GRID_HEIGHT);\n\n    this.position = position;\n\n    this.collider = Rectangle.widthForm(0, 0, this.width, this.height);\n\n    this.camera = new Vector(this.width / 2, this.height / 2);\n    this.player = new Player(this.camera.copy());\n\n    this.blocks = [];\n    for (let i = GRID_SIZE; i < this.width - GRID_SIZE; i += GRID_SIZE) {\n      for (let j = GRID_SIZE; j < this.height - GRID_SIZE; j += GRID_SIZE) {\n        if (Math.random() < 0.02) {\n          this.blocks.push(new Rectangle(i, j, i + GRID_SIZE, j + GRID_SIZE));\n        }\n      }\n    }\n\n    const widthUnits = this.width / WORLD_GRID_WIDTH;\n    const heightUnits = this.height / WORLD_GRID_HEIGHT;\n\n    const B = BOUNDARY,\n      D = DOORWAY_SIZE,\n      GW = WORLD_GRID_WIDTH,\n      GH = WORLD_GRID_HEIGHT;\n\n    this.exits = [];\n\n    for (let x = 0; x < widthUnits; x++) {\n      this.blocks.push(\n        // Top\n        Rectangle.widthForm(-B + x * GW, -B, GW / 2 - D + B, B),\n        Rectangle.widthForm((x + 1 / 2) * GW + D, -B, GW / 2 - D + B, B),\n        // Bottom\n        Rectangle.widthForm(-B + x * GW, heightUnits * GH, GW / 2 - D + B, B),\n        Rectangle.widthForm(\n          (x + 1 / 2) * GW + D,\n          heightUnits * GH,\n          GW / 2 - D + B,\n          B,\n        ),\n      );\n\n      this.exits.push(\n        // Top\n        [\n          Rectangle.widthForm((x + 1 / 2) * GW - D, -B, D * 2, B),\n          new ExitEvent(\n            this.position,\n            new Vector(this.position.x + x, this.position.y - 1),\n            \"up\",\n          ),\n        ],\n        // Bottom\n        [\n          Rectangle.widthForm((x + 1 / 2) * GW - D, heightUnits * GH, D * 2, B),\n          new ExitEvent(\n            this.position,\n            new Vector(this.position.x + x, this.position.y + heightUnits),\n            \"down\",\n          ),\n        ],\n      );\n    }\n\n    for (let y = 0; y < heightUnits; y++) {\n      this.blocks.push(\n        // Left\n        Rectangle.widthForm(-B, -B + y * GH, B, GH / 2 - D + B),\n        Rectangle.widthForm(-B, (y + 1 / 2) * GH + D, B, GH / 2 - D + B),\n        // Right\n        Rectangle.widthForm(widthUnits * GW, -B + y * GH, B, GH / 2 - D + B),\n        Rectangle.widthForm(\n          widthUnits * GW,\n          (y + 1 / 2) * GH + D,\n          B,\n          GH / 2 - D + B,\n        ),\n      );\n\n      this.exits.push(\n        // Left\n        [\n          Rectangle.widthForm(-B, (y + 1 / 2) * GH - D, B, D * 2),\n          new ExitEvent(\n            this.position,\n            new Vector(this.position.x - 1, this.position.y + y),\n            \"left\",\n          ),\n        ],\n        // Right\n        [\n          Rectangle.widthForm(widthUnits * GW, (y + 1 / 2) * GH - D, B, D * 2),\n          new ExitEvent(\n            this.position,\n            new Vector(this.position.x + widthUnits, this.position.y + y),\n            \"right\",\n          ),\n        ],\n      );\n    }\n  }\n\n  start() {\n    this.visited = true;\n    this.backgroundDirty = true;\n  }\n\n  update(deltaTime: number, inputState: InputState, mode: PlayMode) {\n    // ...\n    this.player.update(deltaTime, inputState, this);\n\n    const exit = this.exits.find(([exit]) =>\n      exit.intersectsPoint(this.player.collider.center),\n    );\n\n    if (exit) {\n      mode.onLevelEvent(exit[1]);\n    }\n\n    this.camera = this.player.collider.center.copy();\n    this.camera.x = clamp(\n      this.camera.x,\n      WORLD_GRID_WIDTH / 2,\n      this.width - WORLD_GRID_WIDTH / 2,\n    );\n    this.camera.y = clamp(\n      this.camera.y,\n      WORLD_GRID_HEIGHT / 2,\n      this.height - WORLD_GRID_HEIGHT / 2,\n    );\n  }\n\n  onInput(input: InputEvent) {\n    // waddap\n    this.player.onInput(input, this);\n  }\n\n  interactOnCell(position: Vector) {\n    let removedIndex = -1;\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      if (\n        block.x1 === position.x &&\n        block.y1 === position.y &&\n        block.width === GRID_SIZE &&\n        block.height === GRID_SIZE\n      ) {\n        removedIndex = index;\n        break;\n      }\n    }\n\n    if (removedIndex !== -1) {\n      this.backgroundDirty = true;\n      this.blocks.splice(removedIndex, 1);\n      return;\n    } else {\n      const newRect = Rectangle.widthForm(\n        position.x,\n        position.y,\n        GRID_SIZE,\n        GRID_SIZE,\n      );\n\n      if (\n        !this.collider.intersectsPoint(newRect.midpoint) ||\n        this.exits.some(([exit]) => exit.intersectsRectangle(newRect))\n      ) {\n        return;\n      }\n\n      const overlap = this.player.collider.intersectsBy(newRect);\n\n      if (overlap < 5) {\n        this.backgroundDirty = true;\n        this.blocks.push(newRect);\n      } else {\n        // Do nothing\n      }\n    }\n  }\n\n  draw(screenManager: ScreenManager) {\n    screenManager.setCamera(\n      this.camera.copy().add(new Vector(BOUNDARY, BOUNDARY)),\n    );\n\n    screenManager.uiCanvas.clear();\n\n    if (this.backgroundDirty) {\n      this.backgroundDirty = false;\n\n      const canvas = screenManager.staticWorldCanvas;\n      canvas.clear();\n\n      canvas.translate(BOUNDARY, BOUNDARY);\n\n      canvas.setColor(\"black\");\n      canvas.setLineWidth(5);\n      canvas.strokeRect(0, 0, this.width, this.height);\n\n      canvas.setColor(this.color);\n      canvas.fillRect(0, 0, this.width, this.height);\n\n      canvas.setColor(\"gray\");\n      this.blocks.forEach((block) => block.draw(canvas));\n\n      canvas.translate(-BOUNDARY, -BOUNDARY);\n    }\n\n    const canvas = screenManager.dynamicWorldCanvas;\n    canvas.clear();\n\n    canvas.translate(BOUNDARY, BOUNDARY);\n\n    this.player.draw(canvas);\n\n    canvas.translate(-BOUNDARY, -BOUNDARY);\n  }\n\n  drawForMap(canvas: Canvas) {\n    const INSET = 4;\n\n    const insetRect = (insetBy: number) =>\n      canvas.fillRect(\n        insetBy * INSET,\n        insetBy * INSET,\n        canvas.width - insetBy * INSET * 2,\n        canvas.height - insetBy * INSET * 2,\n      );\n\n    canvas.setColor(\"grey\");\n    insetRect(1);\n\n    canvas.setColor(this.color);\n    insetRect(2);\n  }\n\n  enterFrom(event: ExitEvent) {\n    const BUFF = 10;\n    const map = {\n      up: new Vector(WORLD_GRID_WIDTH / 2, WORLD_GRID_HEIGHT - BUFF),\n      right: new Vector(BUFF, WORLD_GRID_HEIGHT / 2),\n      down: new Vector(WORLD_GRID_WIDTH / 2, BUFF),\n      left: new Vector(WORLD_GRID_WIDTH - BUFF, WORLD_GRID_HEIGHT / 2),\n    };\n\n    const cellInRoom = Vector.diff(event.toKey, this.position);\n\n    this.player.collider.center = Vector.add(\n      new Vector(\n        cellInRoom.x * WORLD_GRID_WIDTH,\n        cellInRoom.y * WORLD_GRID_HEIGHT,\n      ),\n      map[event.direction],\n    );\n\n    this.start();\n  }\n}\n", "import {\n  WORLD_GRID_HEIGHT,\n  WORLD_GRID_WIDTH,\n} from \"../constants/WorldConstants\";\nimport { Direction, ExitEvent } from \"../game-modes/GameEvent\";\nimport { shuffle } from \"../math/Common\";\nimport { Vector } from \"../math/Vector\";\nimport { Room } from \"./Room\";\n\nexport const parseKey = (s: string): Vector => {\n  const [x, y] = s.split(\",\").map((x) => parseInt(x));\n\n  return new Vector(x, y);\n};\n\nexport const encodeKey = (v: Vector): string => {\n  return `${v.x},${v.y}`;\n};\n\nconst makeNewRoomOptions = (direction: Direction): [Vector, number, number][] => {\n  const options: [Vector, number, number][] = [\n    [new Vector(-2, 0), 3, 1],\n    [new Vector(-1, 0), 3, 1],\n    [new Vector(0, 0), 3, 1],\n    [new Vector(0, -2), 1, 3],\n    [new Vector(0, -1), 1, 3],\n    [new Vector(0, 0), 1, 3],\n    [new Vector(0, 0), 1, 1],\n  ];\n\n  switch (direction) {\n    case 'up':\n      options.push([new Vector(-1, -1), 2, 2], [new Vector(0, -1), 2, 2]);\n      break;\n    case 'left':\n      options.push([new Vector(-1, -1), 2, 2], [new Vector(-1, 0), 2, 2]);\n      break;\n    case 'down':\n      options.push([new Vector(-1, 0), 2, 2], [new Vector(0, 0), 2, 2]);\n      break;\n    case 'right':\n      options.push([new Vector(0, -1), 2, 2], [new Vector(0, 0), 2, 2]);\n      break;\n  }\n\n  return shuffle(options);\n};\n\nconst directionMap: Record<Direction, Vector> = {\n  up: new Vector(0, -1),\n  down: new Vector(0, 1),\n  left: new Vector(-1, 0),\n  right: new Vector(1, 0),\n};\n\nexport class RoomWeb {\n  currentRoom: Room;\n\n  map: Map<string, Room>;\n\n  rooms: Room[];\n\n  constructor() {\n    this.map = new Map();\n    this.rooms = [];\n\n    this.currentRoom = this.createRoomWithoutCheckingNeighbors(\n      new Vector(0, 0),\n    );\n  }\n\n  getRoom(position: Vector) {\n    return this.map.get(encodeKey(position));\n  }\n\n  createRoom(position: Vector, w: number = 1, h: number = 1): Room | undefined {\n    let foundNeighbor = false;\n\n    for (let x = 0; x < w; x++) {\n      const upKey = encodeKey(new Vector(position.x + x, position.y - 1));\n      const downKey = encodeKey(new Vector(position.x + x, position.y + h));\n      if (this.map.has(upKey) || this.map.has(downKey)) {\n        foundNeighbor = true;\n        break;\n      }\n    }\n    if (!foundNeighbor) {\n      for (let y = 0; y < h; y++) {\n        const leftKey = encodeKey(new Vector(position.x - 1, position.y + y));\n        const rightKey = encodeKey(new Vector(position.x + w, position.y + y));\n        if (this.map.has(leftKey) || this.map.has(rightKey)) {\n          foundNeighbor = true;\n          break;\n        }\n      }\n    }\n\n    if (!foundNeighbor) {\n      return;\n    }\n\n    for (let x = 0; x < w; x++) {\n      for (let y = 0; y < h; y++) {\n        const key = encodeKey(new Vector(position.x + x, position.y + y));\n\n        const existingRoom = this.map.get(key);\n        if (existingRoom) {\n          return;\n        }\n      }\n    }\n\n    return this.createRoomWithoutCheckingNeighbors(position, w, h);\n  }\n\n  private createRoomWithoutCheckingNeighbors(\n    position: Vector,\n    w: number = 1,\n    h: number = 1,\n  ): Room {\n    const keys = [];\n    for (let x = 0; x < w; x++) {\n      for (let y = 0; y < h; y++) {\n        const key = encodeKey(new Vector(position.x + x, position.y + y));\n        keys.push(key);\n\n        const existingRoom = this.map.get(key);\n        if (existingRoom) {\n          console.error(\"Asked to create an overlapping room!\");\n          throw Error();\n        }\n      }\n    }\n\n    const newRoom = new Room(\n      position,\n      WORLD_GRID_WIDTH * w,\n      WORLD_GRID_HEIGHT * h,\n    );\n\n    for (const key of keys) {\n      this.map.set(key, newRoom);\n    }\n    // this.map.set(newRoom.key, newRoom);\n    this.rooms.push(newRoom);\n\n    return newRoom;\n  }\n\n  currentRoomPosition() {\n    return parseKey(this.currentRoom.key);\n  }\n\n  navigate(event: ExitEvent) {\n    const { direction, fromKey, toKey } = event;\n\n    const nextKey = encodeKey(toKey);\n\n    const currentRoom = this.map.get(encodeKey(fromKey));\n\n    if (!currentRoom) {\n      console.error(\n        \"Exited a room that does not exist!\",\n        fromKey,\n        Array.from(this.map.keys()),\n      );\n      return;\n    }\n\n    const nextRoom = this.map.get(nextKey);\n    if (nextRoom) {\n      this.currentRoom = nextRoom;\n    } else {\n      let newRoom: Room | undefined;\n\n      for (const [offset, w, h] of makeNewRoomOptions(direction)) {\n        newRoom = this.createRoom(Vector.add(toKey, offset), w, h);\n\n        if (newRoom) break;\n      }\n\n      if (!newRoom) {\n        // This should succeed no matter what.\n        newRoom = this.createRoom(toKey, 1, 1);\n      }\n\n      if (!newRoom) {\n        console.error(\"Failed creating new room!\", toKey);\n      }\n\n      this.currentRoom = newRoom!;\n    }\n\n    this.currentRoom.enterFrom(event);\n  }\n}\n", "// import { LevelManager } from \"../level/LevelManager\";\nimport { Room } from \"../room/Room\";\n// import { ExitEvent, LevelEvent } from \"../level/LevelEvent\";\nimport { InputEvent, InputState } from \"../InputManager\";\nimport { ScreenManager } from \"../ScreenManager\";\nimport { GameModeManager } from \"../GameModeManager\";\nimport { GRID_SIZE } from \"../constants/WorldConstants\";\nimport { floorTo } from \"../math/Common\";\nimport { RoomWeb } from \"../room/RoomWeb\";\nimport { ExitEvent, GameEvent } from \"./GameEvent\";\n\nexport class PlayMode {\n  gameModeManager: GameModeManager;\n\n  roomWeb: RoomWeb;\n\n  constructor(gameModeManager: GameModeManager) {\n    this.gameModeManager = gameModeManager;\n\n    this.roomWeb = new RoomWeb();\n    this.startLevel(this.roomWeb.currentRoom);\n  }\n\n  startLevel(room: Room) {\n    room.start(/* this */);\n  }\n\n  onStart() {\n    this.roomWeb.currentRoom.start();\n  }\n\n  onLevelEvent(event: GameEvent) {\n    if (event.isExitEvent()) {\n      const exit = event as ExitEvent;\n      this.roomWeb.navigate(exit);\n    } else if (event.isOpenMapEvent()) {\n      // this.gameModeManager.switchToMode(this.gameModeManager.mapMode);\n    }\n  }\n\n  /**\n   * Update.\n   * @param {number} deltaTime The time elapsed since the last update.\n   * @param {object} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.roomWeb.currentRoom.update(deltaTime, inputState, this);\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.roomWeb.currentRoom.onInput(input);\n  }\n\n  /**\n   * Draw.\n   * @param {ScreenManager} screenManager The screenManager to draw upon.\n   */\n  draw(screenManager: ScreenManager) {\n    this.roomWeb.currentRoom.draw(screenManager);\n  }\n}\n", "import { Input } from \"./constants/Keys\";\nimport { IS_MOBILE } from \"./constants/ScreenConstants\";\nimport { MapMode } from \"./game-modes/MapMode\";\n// import { MapMode } from \"./game-modes/MapMode\";\nimport { PlayMode } from \"./game-modes/PlayMode\";\nimport { InputEvent, InputState } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\ninterface Mode {\n  update(deltaTime: number, inputState: InputState): void;\n  onInput(inputEvent: InputEvent): void;\n  draw(screenManager: ScreenManager): void;\n  onStart(): void;\n}\n\nconst ALL_SECTIONS = [\n  \"horizontal-movement\",\n  \"vertical-movement\",\n  \"map-c\",\n  \"exit-c\",\n  \"zoom-c\",\n];\n\nexport class GameModeManager {\n  playMode: PlayMode;\n  mapMode: MapMode;\n\n  currentMode: Mode;\n\n  constructor() {\n    this.playMode = new PlayMode(this);\n    this.mapMode = new MapMode(this);\n\n    // Probably needs to initially be a menu mode eventually, or some dev-mode tooling\n    this.currentMode = this.playMode;\n    this.playMode.onStart();\n  }\n\n  /**\n   * Update the current gamemode.\n   * @param {number} deltaTime The time that has elapsed since the last update.\n   * @param {InputState} inputState The current state of inputs.\n   */\n  update(deltaTime: number, inputState: InputState) {\n    this.currentMode.update(deltaTime, inputState);\n  }\n\n  switchToMode(mode: Mode) {\n    this.currentMode = mode;\n    mode.onStart();\n  }\n\n  /**\n   * Process an input event\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    let consumed = false;\n    if (this.currentMode === this.playMode) {\n      if (input.isForKey(Input.Map)) {\n        consumed = true;\n        this.switchToMode(this.mapMode);\n      }\n    } else if (this.currentMode === this.mapMode) {\n      if (input.isForKey(Input.Escape) || input.isForKey(Input.Map)) {\n        consumed = false;\n        this.switchToMode(this.playMode);\n      }\n    }\n\n    if (!consumed) {\n      this.currentMode.onInput(input);\n    }\n  }\n\n  /**\n   * Draw the current gamemode.\n   * @param {ScreenManager} screenManager The screenManager object.\n   */\n  draw(screenManager: ScreenManager) {\n    this.currentMode.draw(screenManager);\n  }\n\n  enableSections(sectionIds: string[]) {\n    if (!IS_MOBILE) {\n      return;\n    }\n\n    for (const section of ALL_SECTIONS) {\n      document.getElementById(section)?.classList.add(\"hidden\");\n    }\n\n    for (const section of sectionIds) {\n      document.getElementById(section)?.classList.remove(\"hidden\");\n    }\n  }\n}\n", "import { Input } from \"./constants/Keys\";\nimport { ON_SCREEN_CANVAS_WIDTH, IS_MOBILE } from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nconst KEY_MAP: Record<string, Key> = {\n  \" \": Input.Jump,\n  Escape: Input.Escape,\n  KeyW: Input.Up,\n  KeyA: Input.Left,\n  KeyS: Input.Down,\n  KeyD: Input.Right,\n  KeyE: Input.Interact,\n  KeyM: Input.Map,\n};\n\ntype ValueOf<T> = T[keyof T];\n\ntype Key = ValueOf<typeof Input>;\n\ntype KeyMap = Record<Key, boolean>;\n\nfunction isTouchEvent(event: MouseEvent | TouchEvent): event is TouchEvent {\n  return window.TouchEvent && event instanceof TouchEvent;\n}\n\nexport class InputState {\n  keyMap: KeyMap;\n  mousePosition: Vector;\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  constructor(\n    keyMap: KeyMap,\n    mousePosition: Vector,\n    leftClicking: boolean = false,\n    rightClicking: boolean = false,\n  ) {\n    this.keyMap = keyMap;\n    this.mousePosition = mousePosition;\n    this.leftClicking = leftClicking;\n    this.rightClicking = rightClicking;\n  }\n\n  /**\n   * Check the current value for the horizontal axis input.\n   * @return {number} a value from -1 to 1.\n   */\n  getHorizontalAxis() {\n    return +!!this.keyMap[Input.Right] - +!!this.keyMap[Input.Left];\n  }\n\n  getVerticalAxis() {\n    return +!!this.keyMap[Input.Down] - +!!this.keyMap[Input.Up];\n  }\n\n  /**\n   * Checks whether an input is currently pressed.\n   * @param {Input} input\n   */\n  isPressed(input: Key) {\n    return !!this.keyMap[input];\n  }\n\n  isLeftClicking() {\n    return this.leftClicking;\n  }\n\n  isRightClicking() {\n    return this.rightClicking;\n  }\n\n  static empty() {\n    return new InputState({}, new Vector(0, 0));\n  }\n}\n\nexport class InputEvent {\n  constructor() {}\n\n  isForKey(_key: Key) {\n    return false;\n  }\n\n  isClick() {\n    return false;\n  }\n\n  isScroll() {\n    return false;\n  }\n}\n\nexport class KeyPressEvent extends InputEvent {\n  input: Key;\n\n  constructor(input: Key) {\n    super();\n    this.input = input;\n  }\n\n  isForKey(key: Key) {\n    return key === this.input;\n  }\n}\n\nexport class ClickEvent extends InputEvent {\n  position: Vector;\n  isRight: boolean;\n\n  constructor(position: Vector, isRightClick: boolean) {\n    super();\n    this.position = position;\n    this.isRight = isRightClick;\n  }\n\n  isClick() {\n    return true;\n  }\n\n  isRightClick() {\n    return this.isRight;\n  }\n}\n\nexport class ScrollEvent extends InputEvent {\n  delta: number;\n  discrete: boolean;\n\n  constructor(delta: number, discrete?: boolean) {\n    super();\n    this.delta = delta;\n    this.discrete = !!discrete;\n  }\n\n  isScroll() {\n    return true;\n  }\n}\n\nexport class InputManager {\n  listener: (inputEvent: InputEvent) => void;\n\n  leftClicking: boolean;\n  rightClicking: boolean;\n\n  isButtonDown: KeyMap;\n  mousePosition: Vector;\n\n  canvas: HTMLCanvasElement;\n\n  constructor(listener: (inputEvent: InputEvent) => void) {\n    this.leftClicking = false;\n    this.rightClicking = false;\n\n    this.isButtonDown = {};\n    this.listener = listener;\n    this.mousePosition = new Vector(0, 0);\n\n    this.canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n  }\n\n  /**\n   * Set up event listeners.\n   */\n  init() {\n    const onKeyEvent = (symbol: Key) => {\n      if (this.listener) {\n        this.listener(new KeyPressEvent(symbol));\n      }\n    };\n\n    document.addEventListener(\"keydown\", (e) => {\n      const key = e.code;\n\n      if (e.repeat) {\n        return;\n      }\n      const symbol = KEY_MAP[key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = true;\n      onKeyEvent(symbol);\n    });\n\n    document.addEventListener(\"keyup\", (e) => {\n      const key = e.code;\n\n      const symbol = KEY_MAP[key];\n      if (!symbol) {\n        return;\n      }\n\n      this.isButtonDown[symbol] = false;\n    });\n\n    this.canvas.addEventListener(\n      IS_MOBILE ? \"touchmove\" : \"mousemove\",\n      (event) => {\n        this.mousePosition = this.toCanvasPosition(event);\n      },\n    );\n\n    this.canvas.addEventListener(\n      IS_MOBILE ? \"touchstart\" : \"mousedown\",\n      (event) => {\n        if (IS_MOBILE) {\n          event.preventDefault();\n        }\n        this.mousePosition = this.toCanvasPosition(event);\n\n        const isLeft =\n          isTouchEvent(event) ||\n          (event instanceof MouseEvent && event.button === 0);\n        const isRight = event instanceof MouseEvent && event.button === 2;\n\n        if (isLeft) {\n          this.listener?.(new ClickEvent(this.mousePosition, false));\n          this.leftClicking = true;\n        } else if (isRight) {\n          this.listener?.(new ClickEvent(this.mousePosition, true));\n          this.rightClicking = true;\n        }\n      },\n    );\n\n    this.canvas.addEventListener(\n      IS_MOBILE ? \"touchend\" : \"mouseup\",\n      (event) => {\n        const isLeft =\n          isTouchEvent(event) ||\n          (event instanceof MouseEvent && event.button === 0);\n        const isRight = event instanceof MouseEvent && event.button === 2;\n\n        if (isLeft) {\n          this.leftClicking = false;\n        } else if (isRight) {\n          this.rightClicking = false;\n        }\n      },\n    );\n\n    this.canvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n\n    // Stop current clicks on mouse leave\n    this.canvas.addEventListener(IS_MOBILE ? \"touchend\" : \"mouseleave\", () => {\n      this.leftClicking = false;\n      this.rightClicking = false;\n    });\n\n    this.canvas.addEventListener(\"wheel\", (event) => {\n      this.listener?.(new ScrollEvent(event.deltaY));\n    });\n\n    const wireButton = (id: string, input: Key | (() => InputEvent)) => {\n      const btn = document.getElementById(id);\n\n      if (!btn) {\n        return;\n      }\n\n      btn.addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n\n        if (typeof input === \"function\") {\n          this.listener?.(input());\n        } else {\n          this.isButtonDown[input] = true;\n\n          onKeyEvent(input);\n        }\n      });\n\n      btn.addEventListener(\"touchcancel\", (e) => {\n        e.preventDefault();\n        if (typeof input === \"function\") {\n          // Do nothing\n        } else {\n          this.isButtonDown[input] = false;\n        }\n      });\n\n      btn.addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        if (typeof input === \"function\") {\n          // Do nothing\n        } else {\n          this.isButtonDown[input] = false;\n        }\n      });\n    };\n\n    wireButton(\"left\", Input.Left);\n    wireButton(\"right\", Input.Right);\n    wireButton(\"jump\", Input.Jump);\n    wireButton(\"down\", Input.Down);\n    wireButton(\"map\", Input.Map);\n    wireButton(\"exit\", Input.Escape);\n    wireButton(\"zoom-in\", () => new ScrollEvent(1, true));\n    wireButton(\"zoom-out\", () => new ScrollEvent(-1, true));\n  }\n\n  toCanvasPosition(event: MouseEvent | TouchEvent) {\n    const e = isTouchEvent(event)\n      ? event.touches.item(0) || { clientX: 0, clientY: 0 }\n      : event;\n    return Vector.scale(\n      new Vector(\n        // Subtract half client width and height to have 0, 0 be in the center of the screen\n        e.clientX -\n          this.canvas.offsetLeft +\n          window.scrollX -\n          this.canvas.clientWidth / 2,\n        e.clientY -\n          this.canvas.offsetTop +\n          window.scrollY -\n          this.canvas.clientHeight / 2,\n      ),\n      ((this.canvas.width / this.canvas.clientWidth) * ON_SCREEN_CANVAS_WIDTH) /\n        ON_SCREEN_CANVAS_WIDTH,\n    );\n  }\n\n  /**\n   * @return {InputState} The current state of inputs\n   */\n  getInputState() {\n    return new InputState(\n      this.isButtonDown,\n      this.mousePosition,\n      this.leftClicking,\n      this.rightClicking,\n    );\n  }\n}\n", "import {\n  CANVAS_HEIGHT,\n  CANVAS_WIDTH,\n  ON_SCREEN_CANVAS_HEIGHT,\n  ON_SCREEN_CANVAS_WIDTH,\n} from \"./constants/ScreenConstants\";\nimport { Vector } from \"./math/Vector\";\n\nimport { Canvas } from \"./Canvas\";\n\nconst REAL_CANVAS = Symbol(\"real-canvas\");\n\nfunction getRawCanvas(): HTMLCanvasElement {\n  const rawCanvas = document.getElementById(\"canvas\");\n\n  if (!(rawCanvas instanceof HTMLCanvasElement)) {\n    throw new Error(\"Could not find canvas\");\n  }\n\n  rawCanvas.width = ON_SCREEN_CANVAS_WIDTH;\n  rawCanvas.height = ON_SCREEN_CANVAS_HEIGHT;\n\n  return rawCanvas;\n}\n\nexport class ScreenManager {\n  [REAL_CANVAS]: Canvas;\n  // background: Canvas;\n  // behindGroundCanvas: Canvas;\n  staticWorldCanvas: Canvas;\n  dynamicWorldCanvas: Canvas;\n  uiCanvas: Canvas;\n  camera: Vector;\n\n  constructor() {\n    const screenCanvas = new Canvas(getRawCanvas());\n\n    if (!(screenCanvas instanceof Canvas)) {\n      throw Error(\"No canvas found!\");\n    }\n\n    this[REAL_CANVAS] = screenCanvas;\n\n    // this.background = Canvas.fromScratch(CANVAS_WIDTH * 3, CANVAS_HEIGHT * 4);\n\n    // this.behindGroundCanvas = Canvas.fromScratch(\n    //   CANVAS_WIDTH * 3,\n    //   CANVAS_HEIGHT * 4\n    // );\n    this.staticWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 4,\n    );\n    this.dynamicWorldCanvas = Canvas.fromScratch(\n      CANVAS_WIDTH * 3,\n      CANVAS_HEIGHT * 4,\n    );\n    this.uiCanvas = Canvas.fromScratch(\n      ON_SCREEN_CANVAS_WIDTH,\n      ON_SCREEN_CANVAS_HEIGHT,\n    );\n\n    // Stores the top-left position of the camera\n    this.camera = new Vector(0, 0);\n  }\n\n  setCamera(cameraPosition: Vector) {\n    this.camera = Vector.diff(\n      cameraPosition,\n      new Vector(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2),\n    );\n  }\n\n  drawCanvas(\n    canvas: Canvas,\n    camera: Vector,\n    width = CANVAS_WIDTH,\n    height = CANVAS_HEIGHT,\n  ) {\n    this[REAL_CANVAS].drawImage(\n      canvas,\n      camera.x,\n      camera.y,\n      width,\n      height,\n      0,\n      0,\n      this[REAL_CANVAS].width,\n      this[REAL_CANVAS].height,\n    );\n  }\n\n  drawToScreen() {\n    this[REAL_CANVAS].clear();\n    // this.drawCanvas(this.background, this.camera);\n    // this.drawCanvas(this.behindGroundCanvas, this.camera);\n    this.drawCanvas(this.staticWorldCanvas, this.camera);\n    this.drawCanvas(this.dynamicWorldCanvas, this.camera);\n    this.drawCanvas(\n      this.uiCanvas,\n      new Vector(0, 0),\n      CANVAS_WIDTH,\n      CANVAS_HEIGHT,\n    );\n  }\n\n  static instance = null;\n  static getInstance() {\n    if (this.instance) {\n      return this.instance;\n    }\n\n    return new ScreenManager();\n  }\n}\n", "import { GameModeManager } from \"./GameModeManager\";\nimport { InputEvent, InputManager } from \"./InputManager\";\nimport { ScreenManager } from \"./ScreenManager\";\n\nconst MAX_FRAME_TIME = 1 / 20;\n\nexport class App {\n  gameModeManager: GameModeManager;\n  inputManager: InputManager;\n  screenManager: ScreenManager;\n\n  lastFrameTime = 0;\n\n  constructor() {\n    this.gameModeManager = new GameModeManager();\n    this.inputManager = new InputManager((input) => this.onInput(input));\n    this.screenManager = new ScreenManager();\n\n    this.lastFrameTime = performance.now();\n  }\n\n  start() {\n    this.inputManager.init();\n    requestAnimationFrame(() => this.mainLoop());\n  }\n\n  /**\n   * Function for when an interaction input occurs from the InputManager\n   * @param {InputEvent} input The input event to be processed\n   */\n  onInput(input: InputEvent) {\n    this.gameModeManager.onInput(input);\n  }\n\n  mainLoop() {\n    const now = performance.now();\n\n    const deltaTime = Math.min(\n      (now - this.lastFrameTime) / 1000,\n      MAX_FRAME_TIME,\n    );\n\n    this.gameModeManager.update(deltaTime, this.inputManager.getInputState());\n    this.gameModeManager.draw(this.screenManager);\n    this.screenManager.drawToScreen();\n\n    requestAnimationFrame(() => this.mainLoop());\n    this.lastFrameTime = now;\n  }\n}\n\nconst main = () => {\n  const app = new App();\n\n  app.start();\n};\n\nwindow.onload = () => {\n  main();\n};\n"],
  "mappings": "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",
  "names": ["Up", "Down", "Left", "Right", "Jump", "Interact", "Escape", "Map", "Input", "IS_MOBILE", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "clamp", "x", "low", "high", "sign", "floorTo", "fidelity", "randint", "max", "shuffle", "array", "i", "swapTo", "ZERO", "toHex", "number", "digits", "rgbaColor", "red", "green", "blue", "alpha", "hslaColor", "hue", "saturation", "lightness", "CTX", "CANVAS", "Canvas", "_Canvas", "canvas", "ctx", "x", "y", "width", "height", "inset", "xRadius", "yRadius", "radius", "cornerCut", "short", "startAngle", "toPoint", "sign", "x0", "y0", "x1", "y1", "xControl", "yControl", "xScale", "yScale", "xOffset", "yOffset", "pattern", "colorString", "red", "green", "blue", "alpha", "rgbaColor", "hue", "saturation", "lightness", "hslaColor", "r0", "r1", "imageSource", "sourceX", "sourceY", "sourceWidth", "sourceHeight", "destinationX", "destinationY", "destinationWidth", "destinationHeight", "image", "id", "Vector", "_Vector", "x", "y", "vector", "factor", "otherVector", "magnitude", "a", "b", "xDiff", "yDiff", "v1", "v2", "t", "DEBUG_SHOW_ALL_ROOMS", "MAX_ZOOM", "MIN_ZOOM", "ZOOM_SPEED", "ZOOM_LEVELS", "ZOOMS_REVERSED", "MAP_PLAYER_SCALE", "MAP_CANVAS_SCALE", "MapMode", "gameModeManager", "Vector", "currentRoom", "room", "canvas", "Canvas", "position", "_deltaTime", "inputState", "currentWorldPos", "found", "icon", "inputEvent", "event", "mousePosition", "newRoom", "scroll", "x", "clamp", "y", "hoveredRoomPosition", "floorTo", "screenManager", "currentPlayer", "roomCanvas", "hoveredRoom", "worldPosition", "offset", "ExitEvent", "fromKey", "toKey", "direction", "Rectangle", "_Rectangle", "x1", "y1", "x2", "y2", "point", "Vector", "x", "y", "otherRectangle", "circle", "closestX", "clamp", "closestY", "p0", "pToCenter", "distFromCenter", "circleDistToMyCenter", "horizontalDistance", "verticalDistance", "sign", "canvas", "outset", "inset", "insetBy", "width", "height", "halfWidth", "halfHeight", "rectangles", "rect", "Octagon", "center", "radius", "cornerCut", "rectangle", "rectMid", "mid", "xDiff", "yDiff", "manhattanIdeal", "xDist", "nextX", "xShove", "yDist", "nextY", "yShove", "manhattanOverlap", "PLAYER_MAX_SPEED", "PLAYER_ACCEL", "Player", "position", "Octagon", "Vector", "cursor", "floorTo", "input", "room", "Input", "cursorCell", "deltaTime", "inputState", "inputX", "inputY", "acceleration", "totalVel", "off", "block", "canvas", "DOORWAY_SIZE", "BOUNDARY", "Room", "position", "width", "height", "randint", "encodeKey", "floorTo", "Rectangle", "Vector", "Player", "i", "j", "widthUnits", "heightUnits", "B", "D", "GW", "GH", "x", "ExitEvent", "y", "deltaTime", "inputState", "mode", "exit", "clamp", "input", "removedIndex", "index", "block", "newRect", "screenManager", "canvas", "insetRect", "insetBy", "event", "map", "cellInRoom", "parseKey", "s", "x", "y", "Vector", "encodeKey", "v", "makeNewRoomOptions", "direction", "options", "shuffle", "directionMap", "RoomWeb", "position", "w", "h", "foundNeighbor", "upKey", "downKey", "leftKey", "rightKey", "key", "keys", "newRoom", "Room", "event", "fromKey", "toKey", "nextKey", "nextRoom", "offset", "PlayMode", "gameModeManager", "RoomWeb", "room", "event", "exit", "deltaTime", "inputState", "input", "screenManager", "ALL_SECTIONS", "GameModeManager", "PlayMode", "MapMode", "deltaTime", "inputState", "mode", "input", "consumed", "Input", "screenManager", "sectionIds", "IS_MOBILE", "section", "KEY_MAP", "Input", "isTouchEvent", "event", "InputState", "_InputState", "keyMap", "mousePosition", "leftClicking", "rightClicking", "input", "Vector", "InputEvent", "_key", "KeyPressEvent", "key", "ClickEvent", "position", "isRightClick", "ScrollEvent", "delta", "discrete", "InputManager", "listener", "onKeyEvent", "symbol", "e", "IS_MOBILE", "isLeft", "isRight", "wireButton", "id", "btn", "ON_SCREEN_CANVAS_WIDTH", "REAL_CANVAS", "getRawCanvas", "rawCanvas", "ON_SCREEN_CANVAS_WIDTH", "ON_SCREEN_CANVAS_HEIGHT", "ScreenManager", "_ScreenManager", "screenCanvas", "Canvas", "Vector", "cameraPosition", "canvas", "camera", "width", "height", "MAX_FRAME_TIME", "App", "GameModeManager", "InputManager", "input", "ScreenManager", "now", "deltaTime", "main"]
}
